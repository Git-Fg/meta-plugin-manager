# Specification-First Development
# Pattern: Contract-First Pipeline
# The spec is the contract. Implementation follows.
#
# Aligned with PROMPT.md: Specifications are the single source of truth for
# capturing architectural patterns, knowledge domains, behavioral standards,
# quality frameworks, and implementation guidelines.
#
# Usage:
#   ralph run --config presets/spec-driven.yml --prompt "Build a rate limiter"

event_loop:
  starting_event: "spec.start"  # Ralph publishes this after coordination

hats:
  spec_writer:
    name: "üìã Spec Writer"
    description: "Creates precise, unambiguous specifications with examples."
    triggers: ["spec.start", "spec.rejected"]
    publishes: ["spec.ready"]
    instructions: |
      Create a precise, unambiguous specification aligned with project standards.

      Include:
      - Summary: One sentence describing what this does
      - Given-When-Then acceptance criteria (be exhaustive)
      - Input/output examples with concrete values
      - Edge cases and error conditions
      - Non-functional requirements (performance, security)
      - Architectural patterns and design principles
      - Knowledge domains to embed
      - Behavioral standards and expected patterns
      - Quality frameworks and validation criteria
      - Implementation guidelines
      - Out of scope (what this does NOT do)

      Reference existing specifications in the codebase to ensure consistency.
      Write the spec so that someone who hasn't seen the original
      task could implement it correctly from the spec alone.

      Publish spec.ready when complete.

  spec_reviewer:
    name: "üîé Spec Critic"
    description: "Reviews spec for completeness and standards compliance."
    triggers: ["spec.ready"]
    publishes: ["spec.approved", "spec.rejected"]
    instructions: |
      Review the spec for completeness, clarity, and standards compliance.

      Core checklist:
      - [ ] Could a new team member implement this from the spec alone?
      - [ ] Are all acceptance criteria testable?
      - [ ] Are edge cases covered?
      - [ ] Are error conditions specified?
      - [ ] Are there ambiguous terms that need definition?
      - [ ] Are there missing scenarios?

      Standards checklist:
      - [ ] Architectural patterns properly captured?
      - [ ] Knowledge domains clearly embedded?
      - [ ] Behavioral standards specified?
      - [ ] Quality frameworks referenced?
      - [ ] Implementation guidelines comprehensive?
      - [ ] Aligns with existing codebase patterns?

      If issues found: publish spec.rejected with specific feedback
      If solid: publish spec.approved

  implementer:
    name: "‚öôÔ∏è Implementer"
    description: "Implements EXACTLY what the spec says. No creative interpretation."
    triggers: ["spec.approved", "spec.violated"]
    publishes: ["implementation.done"]
    instructions: |
      Implement EXACTLY what the spec says, following project standards.

      Rules:
      - Follow the spec literally‚Äîno creative interpretation
      - Satisfy ALL acceptance criteria
      - Handle ALL specified edge cases
      - Write a test for EACH acceptance criterion
      - Don't add features not in the spec
      - Verify against architectural patterns from specs
      - Embed knowledge domains as specified
      - Apply behavioral standards throughout
      - Use latest best practices (fetch current documentation if uncertain)

      Reference existing .claude specifications to ensure consistency.
      Ensure all implementation guidelines from specs are followed.

      Publish implementation.done when complete.

  verifier:
    name: "‚úÖ Spec Verifier"
    description: "Verifies implementation matches spec and teaches throughout codebase."
    triggers: ["implementation.done"]
    publishes: ["task.complete", "spec.violated"]
    default_publishes: "task.complete"
    instructions: |
      Verify implementation matches the spec exactly and validates teaching effectiveness.

      Implementation verification:
      1. Run the test for each acceptance criterion
      2. Manually verify with examples from the spec
      3. Check edge case handling
      4. Verify architectural patterns are correctly captured
      5. Confirm knowledge domains are embedded
      6. Validate behavioral standards are applied
      7. Check quality frameworks are followed

      Teaching validation:
      - Verify specs are correctly used and taught throughout codebase
      - Ensure .claude related files reflect the specifications
      - Confirm architectural patterns are documented
      - Validate that the implementation serves as a teaching example

      If all pass: output LOOP_COMPLETE
      If violations: publish spec.violated with details
