{
  "url": "https://modelcontextprotocol.io/docs/develop/build-server",
  "markdown": "# Build an MCP server - Model Context Protocol\n[Skip to main content](#content-area)\n[Model Context Protocol home page![light logo](https://mintcdn.com/mcp/4ZXF1PrDkEaJvXpn/logo/light.svg?fit=max&auto=format&n=4ZXF1PrDkEaJvXpn&q=85&s=4498cb8a57d574005f3dca62bdd49c95)![dark logo](https://mintcdn.com/mcp/4ZXF1PrDkEaJvXpn/logo/dark.svg?fit=max&auto=format&n=4ZXF1PrDkEaJvXpn&q=85&s=c0687c003f8f2cbdb24772ab4c8a522c)](https://modelcontextprotocol.io/)\nSearch...\n⌘K\n-   [Blog](https://blog.modelcontextprotocol.io)\n-   [GitHub](https://github.com/modelcontextprotocol)\nSearch...\nNavigation\nDevelop with MCP\nBuild an MCP server\n[Documentation\n](https://modelcontextprotocol.io/docs/getting-started/intro)[Specification\n](https://modelcontextprotocol.io/specification/2025-11-25)[Community\n](https://modelcontextprotocol.io/community/communication)\n##### Get started\n-   [\n    What is MCP?\n    ](https://modelcontextprotocol.io/docs/getting-started/intro)\n##### About MCP\n-   [\n    Architecture\n    ](https://modelcontextprotocol.io/docs/learn/architecture)\n-   [\n    Servers\n    ](https://modelcontextprotocol.io/docs/learn/server-concepts)\n-   [\n    Clients\n    ](https://modelcontextprotocol.io/docs/learn/client-concepts)\n-   [\n    Versioning\n    ](https://modelcontextprotocol.io/specification/versioning)\n##### Develop with MCP\n-   [\n    Connect to local MCP servers\n    ](https://modelcontextprotocol.io/docs/develop/connect-local-servers)\n-   [\n    Connect to remote MCP Servers\n    ](https://modelcontextprotocol.io/docs/develop/connect-remote-servers)\n-   [\n    Build an MCP server\n    ](https://modelcontextprotocol.io/docs/develop/build-server)\n-   [\n    Build an MCP client\n    ](https://modelcontextprotocol.io/docs/develop/build-client)\n-   [\n    SDKs\n    ](https://modelcontextprotocol.io/docs/sdk)\n-   Security\n##### Developer tools\n-   [\n    MCP Inspector\n    ](https://modelcontextprotocol.io/docs/tools/inspector)\nOn this page\n-   [What we’ll be building](#what-we%E2%80%99ll-be-building)\n-   [Core MCP Concepts](#core-mcp-concepts)\n-   [What’s happening under the hood](#what%E2%80%99s-happening-under-the-hood)\n-   [Troubleshooting](#troubleshooting)\n-   [Next steps](#next-steps)\nDevelop with MCP\n# Build an MCP server\nCopy page\nGet started building your own server to use in Claude for Desktop and other clients.\nCopy page\nIn this tutorial, we’ll build a simple MCP weather server and connect it to a host, Claude for Desktop.\n###\n[​\n](#what-we’ll-be-building)\nWhat we’ll be building\nWe’ll build a server that exposes two tools: `get_alerts` and `get_forecast`. Then we’ll connect the server to an MCP host (in this case, Claude for Desktop):\n![](https://mintcdn.com/mcp/4ZXF1PrDkEaJvXpn/images/current-weather.png?fit=max&auto=format&n=4ZXF1PrDkEaJvXpn&q=85&s=dce7b2f8a06c20ba358e4bd2e75fa4c7)\nServers can connect to any client. We’ve chosen Claude for Desktop here for simplicity, but we also have guides on [building your own client](https://modelcontextprotocol.io/docs/develop/build-client) as well as a [list of other clients here](https://modelcontextprotocol.io/clients).\n###\n[​\n](#core-mcp-concepts)\nCore MCP Concepts\nMCP servers can provide three main types of capabilities:\n1.  **[Resources](https://modelcontextprotocol.io/docs/learn/server-concepts#resources)**: File-like data that can be read by clients (like API responses or file contents)\n2.  **[Tools](https://modelcontextprotocol.io/docs/learn/server-concepts#tools)**: Functions that can be called by the LLM (with user approval)\n3.  **[Prompts](https://modelcontextprotocol.io/docs/learn/server-concepts#prompts)**: Pre-written templates that help users accomplish specific tasks\nThis tutorial will primarily focus on tools.\n-   Python\n-   TypeScript\n-   Java\n-   Kotlin\n-   C#\n-   Rust\nLet’s get started with building our weather server! [You can find the complete code for what we’ll be building here.](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-python)\n###\n[​\n](#prerequisite-knowledge)\nPrerequisite knowledge\nThis quickstart assumes you have familiarity with:\n-   Python\n-   LLMs like Claude\n###\n[​\n](#logging-in-mcp-servers)\nLogging in MCP Servers\nWhen implementing MCP servers, be careful about how you handle logging:**For STDIO-based servers:** Never write to standard output (stdout). This includes:\n-   `print()` statements in Python\n-   `console.log()` in JavaScript\n-   `fmt.Println()` in Go\n-   Similar stdout functions in other languages\nWriting to stdout will corrupt the JSON-RPC messages and break your server.**For HTTP-based servers:** Standard output logging is fine since it doesn’t interfere with HTTP responses.\n###\n[​\n](#best-practices)\nBest Practices\n1.  Use a logging library that writes to stderr or files.\n2.  For Python, be especially careful - `print()` writes to stdout by default.\n###\n[​\n](#quick-examples)\nQuick Examples\nCopy\n```\n# ❌ Bad (STDIO)\nprint(\"Processing request\")\n# ✅ Good (STDIO)\nimport logging\nlogging.info(\"Processing request\")\n```\n###\n[​\n](#system-requirements)\nSystem requirements\n-   Python 3.10 or higher installed.\n-   You must use the Python MCP SDK 1.2.0 or higher.\n###\n[​\n](#set-up-your-environment)\nSet up your environment\nFirst, let’s install `uv` and set up our Python project and environment:\nmacOS/Linux\nWindows\nCopy\n```\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n```\nMake sure to restart your terminal afterwards to ensure that the `uv` command gets picked up.Now, let’s create and set up our project:\nmacOS/Linux\nWindows\nCopy\n```\n# Create a new directory for our project\nuv init weather\ncd weather\n# Create virtual environment and activate it\nuv venv\nsource .venv/bin/activate\n# Install dependencies\nuv add \"mcp[cli]\" httpx\n# Create our server file\ntouch weather.py\n```\nNow let’s dive into building your server.\n##\n[​\n](#building-your-server)\nBuilding your server\n###\n[​\n](#importing-packages-and-setting-up-the-instance)\nImporting packages and setting up the instance\nAdd these to the top of your `weather.py`:\nCopy\n```\nfrom typing import Any\nimport httpx\nfrom mcp.server.fastmcp import FastMCP\n# Initialize FastMCP server\nmcp = FastMCP(\"weather\")\n# Constants\nNWS_API_BASE = \"https://api.weather.gov\"\nUSER_AGENT = \"weather-app/1.0\"\n```\nThe FastMCP class uses Python type hints and docstrings to automatically generate tool definitions, making it easy to create and maintain MCP tools.\n###\n[​\n](#helper-functions)\nHelper functions\nNext, let’s add our helper functions for querying and formatting the data from the National Weather Service API:\nCopy\n```\nasync def make_nws_request(url: str) -> dict[str, Any] | None:\n    \"\"\"Make a request to the NWS API with proper error handling.\"\"\"\n    headers = {\"User-Agent\": USER_AGENT, \"Accept\": \"application/geo+json\"}\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url, headers=headers, timeout=30.0)\n            response.raise_for_status()\n            return response.json()\n        except Exception:\n            return None\ndef format_alert(feature: dict) -> str:\n    \"\"\"Format an alert feature into a readable string.\"\"\"\n    props = feature[\"properties\"]\n    return f\"\"\"\nEvent: {props.get(\"event\", \"Unknown\")}\nArea: {props.get(\"areaDesc\", \"Unknown\")}\nSeverity: {props.get(\"severity\", \"Unknown\")}\nDescription: {props.get(\"description\", \"No description available\")}\nInstructions: {props.get(\"instruction\", \"No specific instructions provided\")}\n\"\"\"\n```\n###\n[​\n](#implementing-tool-execution)\nImplementing tool execution\nThe tool execution handler is responsible for actually executing the logic of each tool. Let’s add it:\nCopy\n```\n@mcp.tool()\nasync def get_alerts(state: str) -> str:\n    \"\"\"Get weather alerts for a US state.\n    Args:\n        state: Two-letter US state code (e.g. CA, NY)\n    \"\"\"\n    url = f\"{NWS_API_BASE}/alerts/active/area/{state}\"\n    data = await make_nws_request(url)\n    if not data or \"features\" not in data:\n        return \"Unable to fetch alerts or no alerts found.\"\n    if not data[\"features\"]:\n        return \"No active alerts for this state.\"\n    alerts = [format_alert(feature) for feature in data[\"features\"]]\n    return \"\\n---\\n\".join(alerts)\n@mcp.tool()\nasync def get_forecast(latitude: float, longitude: float) -> str:\n    \"\"\"Get weather forecast for a location.\n    Args:\n        latitude: Latitude of the location\n        longitude: Longitude of the location\n    \"\"\"\n    # First get the forecast grid endpoint\n    points_url = f\"{NWS_API_BASE}/points/{latitude},{longitude}\"\n    points_data = await make_nws_request(points_url)\n    if not points_data:\n        return \"Unable to fetch forecast data for this location.\"\n    # Get the forecast URL from the points response\n    forecast_url = points_data[\"properties\"][\"forecast\"]\n    forecast_data = await make_nws_request(forecast_url)\n    if not forecast_data:\n        return \"Unable to fetch detailed forecast.\"\n    # Format the periods into a readable forecast\n    periods = forecast_data[\"properties\"][\"periods\"]\n    forecasts = []\n    for period in periods[:5]:  # Only show next 5 periods\n        forecast = f\"\"\"\n{period[\"name\"]}:\nTemperature: {period[\"temperature\"]}°{period[\"temperatureUnit\"]}\nWind: {period[\"windSpeed\"]} {period[\"windDirection\"]}\nForecast: {period[\"detailedForecast\"]}\n\"\"\"\n        forecasts.append(forecast)\n    return \"\\n---\\n\".join(forecasts)\n```\n###\n[​\n](#running-the-server)\nRunning the server\nFinally, let’s initialize and run the server:\nCopy\n```\ndef main():\n    # Initialize and run the server\n    mcp.run(transport=\"stdio\")\nif __name__ == \"__main__\":\n    main()\n```\nYour server is complete! Run `uv run weather.py` to start the MCP server, which will listen for messages from MCP hosts.Let’s now test your server from an existing MCP host, Claude for Desktop.\n##\n[​\n](#testing-your-server-with-claude-for-desktop)\nTesting your server with Claude for Desktop\nClaude for Desktop is not yet available on Linux. Linux users can proceed to the [Building a client](https://modelcontextprotocol.io/docs/develop/build-client) tutorial to build an MCP client that connects to the server we just built.\nFirst, make sure you have Claude for Desktop installed. [You can install the latest version here.](https://claude.ai/download) If you already have Claude for Desktop, **make sure it’s updated to the latest version.**We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at `~/Library/Application Support/Claude/claude_desktop_config.json` in a text editor. Make sure to create the file if it doesn’t exist.For example, if you have [VS Code](https://code.visualstudio.com/) installed:\nmacOS/Linux\nWindows\nCopy\n```\ncode ~/Library/Application\\ Support/Claude/claude_desktop_config.json\n```\nYou’ll then add your servers in the `mcpServers` key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.In this case, we’ll add our single weather server like so:\nmacOS/Linux\nWindows\nCopy\n```\n{\n  \"mcpServers\": {\n    \"weather\": {\n      \"command\": \"uv\",\n      \"args\": [\n        \"--directory\",\n        \"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather\",\n        \"run\",\n        \"weather.py\"\n      ]\n    }\n  }\n}\n```\nYou may need to put the full path to the `uv` executable in the `command` field. You can get this by running `which uv` on macOS/Linux or `where uv` on Windows.\nMake sure you pass in the absolute path to your server. You can get this by running `pwd` on macOS/Linux or `cd` on Windows Command Prompt. On Windows, remember to use double backslashes (`\\\\`) or forward slashes (`/`) in the JSON path.\nThis tells Claude for Desktop:\n1.  There’s an MCP server named “weather”\n2.  To launch it by running `uv --directory /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather run weather.py`\nSave the file, and restart **Claude for Desktop**.\nLet’s get started with building our weather server! [You can find the complete code for what we’ll be building here.](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-typescript)\n###\n[​\n](#prerequisite-knowledge-2)\nPrerequisite knowledge\nThis quickstart assumes you have familiarity with:\n-   TypeScript\n-   LLMs like Claude\n###\n[​\n](#logging-in-mcp-servers-2)\nLogging in MCP Servers\nWhen implementing MCP servers, be careful about how you handle logging:**For STDIO-based servers:** Never write to standard output (stdout). This includes:\n-   `print()` statements in Python\n-   `console.log()` in JavaScript\n-   `fmt.Println()` in Go\n-   Similar stdout functions in other languages\nWriting to stdout will corrupt the JSON-RPC messages and break your server.**For HTTP-based servers:** Standard output logging is fine since it doesn’t interfere with HTTP responses.\n###\n[​\n](#best-practices-2)\nBest Practices\n1.  Use a logging library that writes to stderr or files, such as `logging` in Python.\n2.  For JavaScript, be especially careful - `console.log()` writes to stdout by default.\n###\n[​\n](#quick-examples-2)\nQuick Examples\nCopy\n```\n// ❌ Bad (STDIO)\nconsole.log(\"Server started\");\n// ✅ Good (STDIO)\nconsole.error(\"Server started\"); // stderr is safe\n```\n###\n[​\n](#system-requirements-2)\nSystem requirements\nFor TypeScript, make sure you have the latest version of Node installed.\n###\n[​\n](#set-up-your-environment-2)\nSet up your environment\nFirst, let’s install Node.js and npm if you haven’t already. You can download them from [nodejs.org](https://nodejs.org/). Verify your Node.js installation:\nCopy\n```\nnode --version\nnpm --version\n```\nFor this tutorial, you’ll need Node.js version 16 or higher.Now, let’s create and set up our project:\nmacOS/Linux\nWindows\nCopy\n```\n# Create a new directory for our project\nmkdir weather\ncd weather\n# Initialize a new npm project\nnpm init -y\n# Install dependencies\nnpm install @modelcontextprotocol/sdk zod@3\nnpm install -D @types/node typescript\n# Create our files\nmkdir src\ntouch src/index.ts\n```\nUpdate your package.json to add type: “module” and a build script:\npackage.json\nCopy\n```\n{\n  \"type\": \"module\",\n  \"bin\": {\n    \"weather\": \"./build/index.js\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc && chmod 755 build/index.js\"\n  },\n  \"files\": [\"build\"]\n}\n```\nCreate a `tsconfig.json` in the root of your project:\ntsconfig.json\nCopy\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./build\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\nNow let’s dive into building your server.\n##\n[​\n](#building-your-server-2)\nBuilding your server\n###\n[​\n](#importing-packages-and-setting-up-the-instance-2)\nImporting packages and setting up the instance\nAdd these to the top of your `src/index.ts`:\nCopy\n```\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\nconst NWS_API_BASE = \"https://api.weather.gov\";\nconst USER_AGENT = \"weather-app/1.0\";\n// Create server instance\nconst server = new McpServer({\n  name: \"weather\",\n  version: \"1.0.0\",\n});\n```\n###\n[​\n](#helper-functions-2)\nHelper functions\nNext, let’s add our helper functions for querying and formatting the data from the National Weather Service API:\nCopy\n```\n// Helper function for making NWS API requests\nasync function makeNWSRequest<T>(url: string): Promise<T | null> {\n  const headers = {\n    \"User-Agent\": USER_AGENT,\n    Accept: \"application/geo+json\",\n  };\n  try {\n    const response = await fetch(url, { headers });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return (await response.json()) as T;\n  } catch (error) {\n    console.error(\"Error making NWS request:\", error);\n    return null;\n  }\n}\ninterface AlertFeature {\n  properties: {\n    event?: string;\n    areaDesc?: string;\n    severity?: string;\n    status?: string;\n    headline?: string;\n  };\n}\n// Format alert data\nfunction formatAlert(feature: AlertFeature): string {\n  const props = feature.properties;\n  return [\n    `Event: ${props.event || \"Unknown\"}`,\n    `Area: ${props.areaDesc || \"Unknown\"}`,\n    `Severity: ${props.severity || \"Unknown\"}`,\n    `Status: ${props.status || \"Unknown\"}`,\n    `Headline: ${props.headline || \"No headline\"}`,\n    \"---\",\n  ].join(\"\\n\");\n}\ninterface ForecastPeriod {\n  name?: string;\n  temperature?: number;\n  temperatureUnit?: string;\n  windSpeed?: string;\n  windDirection?: string;\n  shortForecast?: string;\n}\ninterface AlertsResponse {\n  features: AlertFeature[];\n}\ninterface PointsResponse {\n  properties: {\n    forecast?: string;\n  };\n}\ninterface ForecastResponse {\n  properties: {\n    periods: ForecastPeriod[];\n  };\n}\n```\n###\n[​\n](#implementing-tool-execution-2)\nImplementing tool execution\nThe tool execution handler is responsible for actually executing the logic of each tool. Let’s add it:\nCopy\n```\n// Register weather tools\nserver.registerTool(\n  \"get_alerts\",\n  {\n    description: \"Get weather alerts for a state\",\n    inputSchema: {\n      state: z\n        .string()\n        .length(2)\n        .describe(\"Two-letter state code (e.g. CA, NY)\"),\n    },\n  },\n  async ({ state }) => {\n    const stateCode = state.toUpperCase();\n    const alertsUrl = `${NWS_API_BASE}/alerts?area=${stateCode}`;\n    const alertsData = await makeNWSRequest<AlertsResponse>(alertsUrl);\n    if (!alertsData) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Failed to retrieve alerts data\",\n          },\n        ],\n      };\n    }\n    const features = alertsData.features || [];\n    if (features.length === 0) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `No active alerts for ${stateCode}`,\n          },\n        ],\n      };\n    }\n    const formattedAlerts = features.map(formatAlert);\n    const alertsText = `Active alerts for ${stateCode}:\\n\\n${formattedAlerts.join(\"\\n\")}`;\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: alertsText,\n        },\n      ],\n    };\n  },\n);\nserver.registerTool(\n  \"get_forecast\",\n  {\n    description: \"Get weather forecast for a location\",\n    inputSchema: {\n      latitude: z\n        .number()\n        .min(-90)\n        .max(90)\n        .describe(\"Latitude of the location\"),\n      longitude: z\n        .number()\n        .min(-180)\n        .max(180)\n        .describe(\"Longitude of the location\"),\n    },\n  },\n  async ({ latitude, longitude }) => {\n    // Get grid point data\n    const pointsUrl = `${NWS_API_BASE}/points/${latitude.toFixed(4)},${longitude.toFixed(4)}`;\n    const pointsData = await makeNWSRequest<PointsResponse>(pointsUrl);\n    if (!pointsData) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to retrieve grid point data for coordinates: ${latitude}, ${longitude}. This location may not be supported by the NWS API (only US locations are supported).`,\n          },\n        ],\n      };\n    }\n    const forecastUrl = pointsData.properties?.forecast;\n    if (!forecastUrl) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Failed to get forecast URL from grid point data\",\n          },\n        ],\n      };\n    }\n    // Get forecast data\n    const forecastData = await makeNWSRequest<ForecastResponse>(forecastUrl);\n    if (!forecastData) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Failed to retrieve forecast data\",\n          },\n        ],\n      };\n    }\n    const periods = forecastData.properties?.periods || [];\n    if (periods.length === 0) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"No forecast periods available\",\n          },\n        ],\n      };\n    }\n    // Format forecast periods\n    const formattedForecast = periods.map((period: ForecastPeriod) =>\n      [\n        `${period.name || \"Unknown\"}:`,\n        `Temperature: ${period.temperature || \"Unknown\"}°${period.temperatureUnit || \"F\"}`,\n        `Wind: ${period.windSpeed || \"Unknown\"} ${period.windDirection || \"\"}`,\n        `${period.shortForecast || \"No forecast available\"}`,\n        \"---\",\n      ].join(\"\\n\"),\n    );\n    const forecastText = `Forecast for ${latitude}, ${longitude}:\\n\\n${formattedForecast.join(\"\\n\")}`;\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: forecastText,\n        },\n      ],\n    };\n  },\n);\n```\n###\n[​\n](#running-the-server-2)\nRunning the server\nFinally, implement the main function to run the server:\nCopy\n```\nasync function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error(\"Weather MCP Server running on stdio\");\n}\nmain().catch((error) => {\n  console.error(\"Fatal error in main():\", error);\n  process.exit(1);\n});\n```\nMake sure to run `npm run build` to build your server! This is a very important step in getting your server to connect.Let’s now test your server from an existing MCP host, Claude for Desktop.\n##\n[​\n](#testing-your-server-with-claude-for-desktop-2)\nTesting your server with Claude for Desktop\nClaude for Desktop is not yet available on Linux. Linux users can proceed to the [Building a client](https://modelcontextprotocol.io/docs/develop/build-client) tutorial to build an MCP client that connects to the server we just built.\nFirst, make sure you have Claude for Desktop installed. [You can install the latest version here.](https://claude.ai/download) If you already have Claude for Desktop, **make sure it’s updated to the latest version.**We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at `~/Library/Application Support/Claude/claude_desktop_config.json` in a text editor. Make sure to create the file if it doesn’t exist.For example, if you have [VS Code](https://code.visualstudio.com/) installed:\nmacOS/Linux\nWindows\nCopy\n```\ncode ~/Library/Application\\ Support/Claude/claude_desktop_config.json\n```\nYou’ll then add your servers in the `mcpServers` key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.In this case, we’ll add our single weather server like so:\nmacOS/Linux\nWindows\nCopy\n```\n{\n  \"mcpServers\": {\n    \"weather\": {\n      \"command\": \"node\",\n      \"args\": [\"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js\"]\n    }\n  }\n}\n```\nThis tells Claude for Desktop:\n1.  There’s an MCP server named “weather”\n2.  Launch it by running `node /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js`\nSave the file, and restart **Claude for Desktop**.\nThis is a quickstart demo based on Spring AI MCP auto-configuration and boot starters. To learn how to create sync and async MCP Servers, manually, consult the [Java SDK Server](https://modelcontextprotocol.io/sdk/java/mcp-server) documentation.\nLet’s get started with building our weather server! [You can find the complete code for what we’ll be building here.](https://github.com/spring-projects/spring-ai-examples/tree/main/model-context-protocol/weather/starter-stdio-server)For more information, see the [MCP Server Boot Starter](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-starter-docs.html) reference documentation. For manual MCP Server implementation, refer to the [MCP Server Java SDK documentation](https://modelcontextprotocol.io/sdk/java/mcp-server).\n###\n[​\n](#logging-in-mcp-servers-3)\nLogging in MCP Servers\nWhen implementing MCP servers, be careful about how you handle logging:**For STDIO-based servers:** Never write to standard output (stdout). This includes:\n-   `print()` statements in Python\n-   `console.log()` in JavaScript\n-   `fmt.Println()` in Go\n-   Similar stdout functions in other languages\nWriting to stdout will corrupt the JSON-RPC messages and break your server.**For HTTP-based servers:** Standard output logging is fine since it doesn’t interfere with HTTP responses.\n###\n[​\n](#best-practices-3)\nBest Practices\n1.  Use a logging library that writes to stderr or files.\n2.  Ensure any configured logging library will not write to STDOUT\n###\n[​\n](#system-requirements-3)\nSystem requirements\n-   Java 17 or higher installed.\n-   [Spring Boot 3.3.x](https://docs.spring.io/spring-boot/installing.html) or higher\n###\n[​\n](#set-up-your-environment-3)\nSet up your environment\nUse the [Spring Initializer](https://start.spring.io/) to bootstrap the project.You will need to add the following dependencies:\nMaven\nGradle\nCopy\n```\n<dependencies>\n      <dependency>\n          <groupId>org.springframework.ai</groupId>\n          <artifactId>spring-ai-starter-mcp-server</artifactId>\n      </dependency>\n      <dependency>\n          <groupId>org.springframework</groupId>\n          <artifactId>spring-web</artifactId>\n      </dependency>\n</dependencies>\n```\nThen configure your application by setting the application properties:\napplication.properties\napplication.yml\nCopy\n```\nspring.main.bannerMode=off\nlogging.pattern.console=\n```\nThe [Server Configuration Properties](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-starter-docs.html#_configuration_properties) documents all available properties.Now let’s dive into building your server.\n##\n[​\n](#building-your-server-3)\nBuilding your server\n###\n[​\n](#weather-service)\nWeather Service\nLet’s implement a [WeatherService.java](https://github.com/spring-projects/spring-ai-examples/blob/main/model-context-protocol/weather/starter-stdio-server/src/main/java/org/springframework/ai/mcp/sample/server/WeatherService.java) that uses a REST client to query the data from the National Weather Service API:\nCopy\n```\n@Service\npublic class WeatherService {\n\tprivate final RestClient restClient;\n\tpublic WeatherService() {\n\t\tthis.restClient = RestClient.builder()\n\t\t\t.baseUrl(\"https://api.weather.gov\")\n\t\t\t.defaultHeader(\"Accept\", \"application/geo+json\")\n\t\t\t.defaultHeader(\"User-Agent\", \"WeatherApiClient/1.0 ([email protected])\")\n\t\t\t.build();\n\t}\n  @Tool(description = \"Get weather forecast for a specific latitude/longitude\")\n  public String getWeatherForecastByLocation(\n      double latitude,   // Latitude coordinate\n      double longitude   // Longitude coordinate\n  ) {\n      // Returns detailed forecast including:\n      // - Temperature and unit\n      // - Wind speed and direction\n      // - Detailed forecast description\n  }\n  @Tool(description = \"Get weather alerts for a US state\")\n  public String getAlerts(\n      @ToolParam(description = \"Two-letter US state code (e.g. CA, NY)\") String state\n  ) {\n      // Returns active alerts including:\n      // - Event type\n      // - Affected area\n      // - Severity\n      // - Description\n      // - Safety instructions\n  }\n  // ......\n}\n```\nThe `@Service` annotation will auto-register the service in your application context. The Spring AI `@Tool` annotation makes it easy to create and maintain MCP tools.The auto-configuration will automatically register these tools with the MCP server.\n###\n[​\n](#create-your-boot-application)\nCreate your Boot Application\nCopy\n```\n@SpringBootApplication\npublic class McpServerApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(McpServerApplication.class, args);\n\t}\n\t@Bean\n\tpublic ToolCallbackProvider weatherTools(WeatherService weatherService) {\n\t\treturn  MethodToolCallbackProvider.builder().toolObjects(weatherService).build();\n\t}\n}\n```\nUses the `MethodToolCallbackProvider` utils to convert the `@Tools` into actionable callbacks used by the MCP server.\n###\n[​\n](#running-the-server-3)\nRunning the server\nFinally, let’s build the server:\nCopy\n```\n./mvnw clean install\n```\nThis will generate an `mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar` file within the `target` folder.Let’s now test your server from an existing MCP host, Claude for Desktop.\n##\n[​\n](#testing-your-server-with-claude-for-desktop-3)\nTesting your server with Claude for Desktop\nClaude for Desktop is not yet available on Linux.\nFirst, make sure you have Claude for Desktop installed. [You can install the latest version here.](https://claude.ai/download) If you already have Claude for Desktop, **make sure it’s updated to the latest version.**We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at `~/Library/Application Support/Claude/claude_desktop_config.json` in a text editor. Make sure to create the file if it doesn’t exist.For example, if you have [VS Code](https://code.visualstudio.com/) installed:\nmacOS/Linux\nWindows\nCopy\n```\ncode ~/Library/Application\\ Support/Claude/claude_desktop_config.json\n```\nYou’ll then add your servers in the `mcpServers` key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.In this case, we’ll add our single weather server like so:\nmacOS/Linux\nWindows\nCopy\n```\n{\n  \"mcpServers\": {\n    \"spring-ai-mcp-weather\": {\n      \"command\": \"java\",\n      \"args\": [\n        \"-Dspring.ai.mcp.server.stdio=true\",\n        \"-jar\",\n        \"/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar\"\n      ]\n    }\n  }\n}\n```\nMake sure you pass in the absolute path to your server.\nThis tells Claude for Desktop:\n1.  There’s an MCP server named “my-weather-server”\n2.  To launch it by running `java -jar /ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar`\nSave the file, and restart **Claude for Desktop**.\n##\n[​\n](#testing-your-server-with-java-client)\nTesting your server with Java client\n###\n[​\n](#create-an-mcp-client-manually)\nCreate an MCP Client manually\nUse the `McpClient` to connect to the server:\nCopy\n```\nvar stdioParams = ServerParameters.builder(\"java\")\n  .args(\"-jar\", \"/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar\")\n  .build();\nvar stdioTransport = new StdioClientTransport(stdioParams);\nvar mcpClient = McpClient.sync(stdioTransport).build();\nmcpClient.initialize();\nListToolsResult toolsList = mcpClient.listTools();\nCallToolResult weather = mcpClient.callTool(\n  new CallToolRequest(\"getWeatherForecastByLocation\",\n      Map.of(\"latitude\", \"47.6062\", \"longitude\", \"-122.3321\")));\nCallToolResult alert = mcpClient.callTool(\n  new CallToolRequest(\"getAlerts\", Map.of(\"state\", \"NY\")));\nmcpClient.closeGracefully();\n```\n###\n[​\n](#use-mcp-client-boot-starter)\nUse MCP Client Boot Starter\nCreate a new boot starter application using the `spring-ai-starter-mcp-client` dependency:\nCopy\n```\n<dependency>\n    <groupId>org.springframework.ai</groupId>\n    <artifactId>spring-ai-starter-mcp-client</artifactId>\n</dependency>\n```\nand set the `spring.ai.mcp.client.stdio.servers-configuration` property to point to your `claude_desktop_config.json`. You can reuse the existing Anthropic Desktop configuration:\nCopy\n```\nspring.ai.mcp.client.stdio.servers-configuration=file:PATH/TO/claude_desktop_config.json\n```\nWhen you start your client application, the auto-configuration will automatically create MCP clients from the claude\\_desktop\\_config.json.For more information, see the [MCP Client Boot Starters](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-client-docs.html) reference documentation.\n##\n[​\n](#more-java-mcp-server-examples)\nMore Java MCP Server examples\nThe [starter-webflux-server](https://github.com/spring-projects/spring-ai-examples/tree/main/model-context-protocol/weather/starter-webflux-server) demonstrates how to create an MCP server using SSE transport. It showcases how to define and register MCP Tools, Resources, and Prompts, using the Spring Boot’s auto-configuration capabilities.\nLet’s get started with building our weather server! [You can find the complete code for what we’ll be building here.](https://github.com/modelcontextprotocol/kotlin-sdk/tree/main/samples/weather-stdio-server)\n###\n[​\n](#prerequisite-knowledge-3)\nPrerequisite knowledge\nThis quickstart assumes you have familiarity with:\n-   Kotlin\n-   LLMs like Claude\n###\n[​\n](#system-requirements-4)\nSystem requirements\n-   Java 17 or higher installed.\n###\n[​\n](#set-up-your-environment-4)\nSet up your environment\nFirst, let’s install `java` and `gradle` if you haven’t already. You can download `java` from [official Oracle JDK website](https://www.oracle.com/java/technologies/downloads/). Verify your `java` installation:\nCopy\n```\njava --version\n```\nNow, let’s create and set up your project:\nmacOS/Linux\nWindows\nCopy\n```\n# Create a new directory for our project\nmkdir weather\ncd weather\n# Initialize a new kotlin project\ngradle init\n```\nAfter running `gradle init`, you will be presented with options for creating your project. Select **Application** as the project type, **Kotlin** as the programming language, and **Java 17** as the Java version.Alternatively, you can create a Kotlin application using the [IntelliJ IDEA project wizard](https://kotlinlang.org/docs/jvm-get-started.html).After creating the project, add the following dependencies:\nbuild.gradle.kts\nbuild.gradle\nCopy\n```\nval mcpVersion = \"0.4.0\"\nval slf4jVersion = \"2.0.9\"\nval ktorVersion = \"3.1.1\"\ndependencies {\n    implementation(\"io.modelcontextprotocol:kotlin-sdk:$mcpVersion\")\n    implementation(\"org.slf4j:slf4j-nop:$slf4jVersion\")\n    implementation(\"io.ktor:ktor-client-content-negotiation:$ktorVersion\")\n    implementation(\"io.ktor:ktor-serialization-kotlinx-json:$ktorVersion\")\n}\n```\nAlso, add the following plugins to your build script:\nbuild.gradle.kts\nbuild.gradle\nCopy\n```\nplugins {\n    kotlin(\"plugin.serialization\") version \"your_version_of_kotlin\"\n    id(\"com.gradleup.shadow\") version \"8.3.9\"\n}\n```\nNow let’s dive into building your server.\n##\n[​\n](#building-your-server-4)\nBuilding your server\n###\n[​\n](#setting-up-the-instance)\nSetting up the instance\nAdd a server initialization function:\nCopy\n```\n// Main function to run the MCP server\nfun `run mcp server`() {\n    // Create the MCP Server instance with a basic implementation\n    val server = Server(\n        Implementation(\n            name = \"weather\", // Tool name is \"weather\"\n            version = \"1.0.0\" // Version of the implementation\n        ),\n        ServerOptions(\n            capabilities = ServerCapabilities(tools = ServerCapabilities.Tools(listChanged = true))\n        )\n    )\n    // Create a transport using standard IO for server communication\n    val transport = StdioServerTransport(\n        System.`in`.asInput(),\n        System.out.asSink().buffered()\n    )\n    runBlocking {\n        server.connect(transport)\n        val done = Job()\n        server.onClose {\n            done.complete()\n        }\n        done.join()\n    }\n}\n```\n###\n[​\n](#weather-api-helper-functions)\nWeather API helper functions\nNext, let’s add functions and data classes for querying and converting responses from the National Weather Service API:\nCopy\n```\n// Extension function to fetch forecast information for given latitude and longitude\nsuspend fun HttpClient.getForecast(latitude: Double, longitude: Double): List<String> {\n    val points = this.get(\"/points/$latitude,$longitude\").body<Points>()\n    val forecast = this.get(points.properties.forecast).body<Forecast>()\n    return forecast.properties.periods.map { period ->\n        \"\"\"\n            ${period.name}:\n            Temperature: ${period.temperature} ${period.temperatureUnit}\n            Wind: ${period.windSpeed} ${period.windDirection}\n            Forecast: ${period.detailedForecast}\n        \"\"\".trimIndent()\n    }\n}\n// Extension function to fetch weather alerts for a given state\nsuspend fun HttpClient.getAlerts(state: String): List<String> {\n    val alerts = this.get(\"/alerts/active/area/$state\").body<Alert>()\n    return alerts.features.map { feature ->\n        \"\"\"\n            Event: ${feature.properties.event}\n            Area: ${feature.properties.areaDesc}\n            Severity: ${feature.properties.severity}\n            Description: ${feature.properties.description}\n            Instruction: ${feature.properties.instruction}\n        \"\"\".trimIndent()\n    }\n}\n@Serializable\ndata class Points(\n    val properties: Properties\n) {\n    @Serializable\n    data class Properties(val forecast: String)\n}\n@Serializable\ndata class Forecast(\n    val properties: Properties\n) {\n    @Serializable\n    data class Properties(val periods: List<Period>)\n    @Serializable\n    data class Period(\n        val number: Int, val name: String, val startTime: String, val endTime: String,\n        val isDaytime: Boolean, val temperature: Int, val temperatureUnit: String,\n        val temperatureTrend: String, val probabilityOfPrecipitation: JsonObject,\n        val windSpeed: String, val windDirection: String,\n        val shortForecast: String, val detailedForecast: String,\n    )\n}\n@Serializable\ndata class Alert(\n    val features: List<Feature>\n) {\n    @Serializable\n    data class Feature(\n        val properties: Properties\n    )\n    @Serializable\n    data class Properties(\n        val event: String, val areaDesc: String, val severity: String,\n        val description: String, val instruction: String?,\n    )\n}\n```\n###\n[​\n](#implementing-tool-execution-3)\nImplementing tool execution\nThe tool execution handler is responsible for actually executing the logic of each tool. Let’s add it:\nCopy\n```\n// Create an HTTP client with a default request configuration and JSON content negotiation\nval httpClient = HttpClient {\n    defaultRequest {\n        url(\"https://api.weather.gov\")\n        headers {\n            append(\"Accept\", \"application/geo+json\")\n            append(\"User-Agent\", \"WeatherApiClient/1.0\")\n        }\n        contentType(ContentType.Application.Json)\n    }\n    // Install content negotiation plugin for JSON serialization/deserialization\n    install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }\n}\n// Register a tool to fetch weather alerts by state\nserver.addTool(\n    name = \"get_alerts\",\n    description = \"\"\"\n        Get weather alerts for a US state. Input is Two-letter US state code (e.g. CA, NY)\n    \"\"\".trimIndent(),\n    inputSchema = Tool.Input(\n        properties = buildJsonObject {\n            putJsonObject(\"state\") {\n                put(\"type\", \"string\")\n                put(\"description\", \"Two-letter US state code (e.g. CA, NY)\")\n            }\n        },\n        required = listOf(\"state\")\n    )\n) { request ->\n    val state = request.arguments[\"state\"]?.jsonPrimitive?.content\n    if (state == null) {\n        return@addTool CallToolResult(\n            content = listOf(TextContent(\"The 'state' parameter is required.\"))\n        )\n    }\n    val alerts = httpClient.getAlerts(state)\n    CallToolResult(content = alerts.map { TextContent(it) })\n}\n// Register a tool to fetch weather forecast by latitude and longitude\nserver.addTool(\n    name = \"get_forecast\",\n    description = \"\"\"\n        Get weather forecast for a specific latitude/longitude\n    \"\"\".trimIndent(),\n    inputSchema = Tool.Input(\n        properties = buildJsonObject {\n            putJsonObject(\"latitude\") { put(\"type\", \"number\") }\n            putJsonObject(\"longitude\") { put(\"type\", \"number\") }\n        },\n        required = listOf(\"latitude\", \"longitude\")\n    )\n) { request ->\n    val latitude = request.arguments[\"latitude\"]?.jsonPrimitive?.doubleOrNull\n    val longitude = request.arguments[\"longitude\"]?.jsonPrimitive?.doubleOrNull\n    if (latitude == null || longitude == null) {\n        return@addTool CallToolResult(\n            content = listOf(TextContent(\"The 'latitude' and 'longitude' parameters are required.\"))\n        )\n    }\n    val forecast = httpClient.getForecast(latitude, longitude)\n    CallToolResult(content = forecast.map { TextContent(it) })\n}\n```\n###\n[​\n](#running-the-server-4)\nRunning the server\nFinally, implement the main function to run the server:\nCopy\n```\nfun main() = `run mcp server`()\n```\nMake sure to run `./gradlew build` to build your server. This is a very important step in getting your server to connect.Let’s now test your server from an existing MCP host, Claude for Desktop.\n##\n[​\n](#testing-your-server-with-claude-for-desktop-4)\nTesting your server with Claude for Desktop\nClaude for Desktop is not yet available on Linux. Linux users can proceed to the [Building a client](https://modelcontextprotocol.io/docs/develop/build-client) tutorial to build an MCP client that connects to the server we just built.\nFirst, make sure you have Claude for Desktop installed. [You can install the latest version here.](https://claude.ai/download) If you already have Claude for Desktop, **make sure it’s updated to the latest version.**We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at `~/Library/Application Support/Claude/claude_desktop_config.json` in a text editor. Make sure to create the file if it doesn’t exist.For example, if you have [VS Code](https://code.visualstudio.com/) installed:\nmacOS/Linux\nWindows\nCopy\n```\ncode ~/Library/Application\\ Support/Claude/claude_desktop_config.json\n```\nYou’ll then add your servers in the `mcpServers` key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.In this case, we’ll add our single weather server like so:\nmacOS/Linux\nWindows\nCopy\n```\n{\n  \"mcpServers\": {\n    \"weather\": {\n      \"command\": \"java\",\n      \"args\": [\n        \"-jar\",\n        \"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/libs/weather-0.1.0-all.jar\"\n      ]\n    }\n  }\n}\n```\nThis tells Claude for Desktop:\n1.  There’s an MCP server named “weather”\n2.  Launch it by running `java -jar /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/libs/weather-0.1.0-all.jar`\nSave the file, and restart **Claude for Desktop**.\nLet’s get started with building our weather server! [You can find the complete code for what we’ll be building here.](https://github.com/modelcontextprotocol/csharp-sdk/tree/main/samples/QuickstartWeatherServer)\n###\n[​\n](#prerequisite-knowledge-4)\nPrerequisite knowledge\nThis quickstart assumes you have familiarity with:\n-   C#\n-   LLMs like Claude\n-   .NET 8 or higher\n###\n[​\n](#logging-in-mcp-servers-4)\nLogging in MCP Servers\nWhen implementing MCP servers, be careful about how you handle logging:**For STDIO-based servers:** Never write to standard output (stdout). This includes:\n-   `print()` statements in Python\n-   `console.log()` in JavaScript\n-   `fmt.Println()` in Go\n-   Similar stdout functions in other languages\nWriting to stdout will corrupt the JSON-RPC messages and break your server.**For HTTP-based servers:** Standard output logging is fine since it doesn’t interfere with HTTP responses.\n###\n[​\n](#best-practices-4)\nBest Practices\n1.  Use a logging library that writes to stderr or files\n###\n[​\n](#system-requirements-5)\nSystem requirements\n-   [.NET 8 SDK](https://dotnet.microsoft.com/download/dotnet/8.0) or higher installed.\n###\n[​\n](#set-up-your-environment-5)\nSet up your environment\nFirst, let’s install `dotnet` if you haven’t already. You can download `dotnet` from [official Microsoft .NET website](https://dotnet.microsoft.com/download/). Verify your `dotnet` installation:\nCopy\n```\ndotnet --version\n```\nNow, let’s create and set up your project:\nmacOS/Linux\nWindows\nCopy\n```\n# Create a new directory for our project\nmkdir weather\ncd weather\n# Initialize a new C# project\ndotnet new console\n```\nAfter running `dotnet new console`, you will be presented with a new C# project. You can open the project in your favorite IDE, such as [Visual Studio](https://visualstudio.microsoft.com/) or [Rider](https://www.jetbrains.com/rider/). Alternatively, you can create a C# application using the [Visual Studio project wizard](https://learn.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-console?view=vs-2022). After creating the project, add NuGet package for the Model Context Protocol SDK and hosting:\nCopy\n```\n# Add the Model Context Protocol SDK NuGet package\ndotnet add package ModelContextProtocol --prerelease\n# Add the .NET Hosting NuGet package\ndotnet add package Microsoft.Extensions.Hosting\n```\nNow let’s dive into building your server.\n##\n[​\n](#building-your-server-5)\nBuilding your server\nOpen the `Program.cs` file in your project and replace its contents with the following code:\nCopy\n```\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing ModelContextProtocol;\nusing System.Net.Http.Headers;\nvar builder = Host.CreateEmptyApplicationBuilder(settings: null);\nbuilder.Services.AddMcpServer()\n    .WithStdioServerTransport()\n    .WithToolsFromAssembly();\nbuilder.Services.AddSingleton(_ =>\n{\n    var client = new HttpClient() { BaseAddress = new Uri(\"https://api.weather.gov\") };\n    client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"weather-tool\", \"1.0\"));\n    return client;\n});\nvar app = builder.Build();\nawait app.RunAsync();\n```\nWhen creating the `ApplicationHostBuilder`, ensure you use `CreateEmptyApplicationBuilder` instead of `CreateDefaultBuilder`. This ensures that the server does not write any additional messages to the console. This is only necessary for servers using STDIO transport.\nThis code sets up a basic console application that uses the Model Context Protocol SDK to create an MCP server with standard I/O transport.\n###\n[​\n](#weather-api-helper-functions-2)\nWeather API helper functions\nCreate an extension class for `HttpClient` which helps simplify JSON request handling:\nCopy\n```\nusing System.Text.Json;\ninternal static class HttpClientExt\n{\n    public static async Task<JsonDocument> ReadJsonDocumentAsync(this HttpClient client, string requestUri)\n    {\n        using var response = await client.GetAsync(requestUri);\n        response.EnsureSuccessStatusCode();\n        return await JsonDocument.ParseAsync(await response.Content.ReadAsStreamAsync());\n    }\n}\n```\nNext, define a class with the tool execution handlers for querying and converting responses from the National Weather Service API:\nCopy\n```\nusing ModelContextProtocol.Server;\nusing System.ComponentModel;\nusing System.Globalization;\nusing System.Text.Json;\nnamespace QuickstartWeatherServer.Tools;\n[McpServerToolType]\npublic static class WeatherTools\n{\n    [McpServerTool, Description(\"Get weather alerts for a US state code.\")]\n    public static async Task<string> GetAlerts(\n        HttpClient client,\n        [Description(\"The US state code to get alerts for.\")] string state)\n    {\n        using var jsonDocument = await client.ReadJsonDocumentAsync($\"/alerts/active/area/{state}\");\n        var jsonElement = jsonDocument.RootElement;\n        var alerts = jsonElement.GetProperty(\"features\").EnumerateArray();\n        if (!alerts.Any())\n        {\n            return \"No active alerts for this state.\";\n        }\n        return string.Join(\"\\n--\\n\", alerts.Select(alert =>\n        {\n            JsonElement properties = alert.GetProperty(\"properties\");\n            return $\"\"\"\n                    Event: {properties.GetProperty(\"event\").GetString()}\n                    Area: {properties.GetProperty(\"areaDesc\").GetString()}\n                    Severity: {properties.GetProperty(\"severity\").GetString()}\n                    Description: {properties.GetProperty(\"description\").GetString()}\n                    Instruction: {properties.GetProperty(\"instruction\").GetString()}\n                    \"\"\";\n        }));\n    }\n    [McpServerTool, Description(\"Get weather forecast for a location.\")]\n    public static async Task<string> GetForecast(\n        HttpClient client,\n        [Description(\"Latitude of the location.\")] double latitude,\n        [Description(\"Longitude of the location.\")] double longitude)\n    {\n        var pointUrl = string.Create(CultureInfo.InvariantCulture, $\"/points/{latitude},{longitude}\");\n        using var jsonDocument = await client.ReadJsonDocumentAsync(pointUrl);\n        var forecastUrl = jsonDocument.RootElement.GetProperty(\"properties\").GetProperty(\"forecast\").GetString()\n            ?? throw new Exception($\"No forecast URL provided by {client.BaseAddress}points/{latitude},{longitude}\");\n        using var forecastDocument = await client.ReadJsonDocumentAsync(forecastUrl);\n        var periods = forecastDocument.RootElement.GetProperty(\"properties\").GetProperty(\"periods\").EnumerateArray();\n        return string.Join(\"\\n---\\n\", periods.Select(period => $\"\"\"\n                {period.GetProperty(\"name\").GetString()}\n                Temperature: {period.GetProperty(\"temperature\").GetInt32()}°F\n                Wind: {period.GetProperty(\"windSpeed\").GetString()} {period.GetProperty(\"windDirection\").GetString()}\n                Forecast: {period.GetProperty(\"detailedForecast\").GetString()}\n                \"\"\"));\n    }\n}\n```\n###\n[​\n](#running-the-server-5)\nRunning the server\nFinally, run the server using the following command:\nCopy\n```\ndotnet run\n```\nThis will start the server and listen for incoming requests on standard input/output.\n##\n[​\n](#testing-your-server-with-claude-for-desktop-5)\nTesting your server with Claude for Desktop\nClaude for Desktop is not yet available on Linux. Linux users can proceed to the [Building a client](https://modelcontextprotocol.io/docs/develop/build-client) tutorial to build an MCP client that connects to the server we just built.\nFirst, make sure you have Claude for Desktop installed. [You can install the latest version here.](https://claude.ai/download) If you already have Claude for Desktop, **make sure it’s updated to the latest version.** We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at `~/Library/Application Support/Claude/claude_desktop_config.json` in a text editor. Make sure to create the file if it doesn’t exist. For example, if you have [VS Code](https://code.visualstudio.com/) installed:\nmacOS/Linux\nWindows\nCopy\n```\ncode ~/Library/Application\\ Support/Claude/claude_desktop_config.json\n```\nYou’ll then add your servers in the `mcpServers` key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured. In this case, we’ll add our single weather server like so:\nmacOS/Linux\nWindows\nCopy\n```\n{\n  \"mcpServers\": {\n    \"weather\": {\n      \"command\": \"dotnet\",\n      \"args\": [\"run\", \"--project\", \"/ABSOLUTE/PATH/TO/PROJECT\", \"--no-build\"]\n    }\n  }\n}\n```\nThis tells Claude for Desktop:\n1.  There’s an MCP server named “weather”\n2.  Launch it by running `dotnet run /ABSOLUTE/PATH/TO/PROJECT` Save the file, and restart **Claude for Desktop**.\nLet’s get started with building our weather server! [You can find the complete code for what we’ll be building here.](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-rust)\n###\n[​\n](#prerequisite-knowledge-5)\nPrerequisite knowledge\nThis quickstart assumes you have familiarity with:\n-   Rust programming language\n-   Async/await in Rust\n-   LLMs like Claude\n###\n[​\n](#logging-in-mcp-servers-5)\nLogging in MCP Servers\nWhen implementing MCP servers, be careful about how you handle logging:**For STDIO-based servers:** Never write to standard output (stdout). This includes:\n-   `print()` statements in Python\n-   `console.log()` in JavaScript\n-   `println!()` in Rust\n-   Similar stdout functions in other languages\nWriting to stdout will corrupt the JSON-RPC messages and break your server.**For HTTP-based servers:** Standard output logging is fine since it doesn’t interfere with HTTP responses.\n###\n[​\n](#best-practices-5)\nBest Practices\n1.  Use a logging library that writes to stderr or files, such as `tracing` or `log` in Rust.\n2.  Configure your logging framework to avoid stdout output.\n###\n[​\n](#quick-examples-3)\nQuick Examples\nCopy\n```\n// ❌ Bad (STDIO)\nprintln!(\"Processing request\");\n// ✅ Good (STDIO)\nuse tracing::info;\ninfo!(\"Processing request\"); // writes to stderr\n```\n###\n[​\n](#system-requirements-6)\nSystem requirements\n-   Rust 1.70 or higher installed.\n-   Cargo (comes with Rust installation).\n###\n[​\n](#set-up-your-environment-6)\nSet up your environment\nFirst, let’s install Rust if you haven’t already. You can install Rust from [rust-lang.org](https://www.rust-lang.org/tools/install):\nmacOS/Linux\nWindows\nCopy\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\nVerify your Rust installation:\nCopy\n```\nrustc --version\ncargo --version\n```\nNow, let’s create and set up our project:\nmacOS/Linux\nWindows\nCopy\n```\n# Create a new Rust project\ncargo new weather\ncd weather\n```\nUpdate your `Cargo.toml` to add the required dependencies:\nCargo.toml\nCopy\n```\n[package]\nname = \"weather\"\nversion = \"0.1.0\"\nedition = \"2024\"\n[dependencies]\nrmcp = { version = \"0.3\", features = [\"server\", \"macros\", \"transport-io\"] }\ntokio = { version = \"1.46\", features = [\"full\"] }\nreqwest = { version = \"0.12\", features = [\"json\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nanyhow = \"1.0\"\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\", \"std\", \"fmt\"] }\n```\nNow let’s dive into building your server.\n##\n[​\n](#building-your-server-6)\nBuilding your server\n###\n[​\n](#importing-packages-and-constants)\nImporting packages and constants\nOpen `src/main.rs` and add these imports and constants at the top:\nCopy\n```\nuse anyhow::Result;\nuse rmcp::{\n    ServerHandler, ServiceExt,\n    handler::server::{router::tool::ToolRouter, tool::Parameters},\n    model::*,\n    schemars, tool, tool_handler, tool_router,\n};\nuse serde::Deserialize;\nuse serde::de::DeserializeOwned;\nconst NWS_API_BASE: &str = \"https://api.weather.gov\";\nconst USER_AGENT: &str = \"weather-app/1.0\";\n```\nThe `rmcp` crate provides the Model Context Protocol SDK for Rust, with features for server implementation, procedural macros, and stdio transport.\n###\n[​\n](#data-structures)\nData structures\nNext, let’s define the data structures for deserializing responses from the National Weather Service API:\nCopy\n```\n#[derive(Debug, Deserialize)]\nstruct AlertsResponse {\n    features: Vec<AlertFeature>,\n}\n#[derive(Debug, Deserialize)]\nstruct AlertFeature {\n    properties: AlertProperties,\n}\n#[derive(Debug, Deserialize)]\nstruct AlertProperties {\n    event: Option<String>,\n    #[serde(rename = \"areaDesc\")]\n    area_desc: Option<String>,\n    severity: Option<String>,\n    description: Option<String>,\n    instruction: Option<String>,\n}\n#[derive(Debug, Deserialize)]\nstruct PointsResponse {\n    properties: PointsProperties,\n}\n#[derive(Debug, Deserialize)]\nstruct PointsProperties {\n    forecast: String,\n}\n#[derive(Debug, Deserialize)]\nstruct ForecastResponse {\n    properties: ForecastProperties,\n}\n#[derive(Debug, Deserialize)]\nstruct ForecastProperties {\n    periods: Vec<ForecastPeriod>,\n}\n#[derive(Debug, Deserialize)]\nstruct ForecastPeriod {\n    name: String,\n    temperature: i32,\n    #[serde(rename = \"temperatureUnit\")]\n    temperature_unit: String,\n    #[serde(rename = \"windSpeed\")]\n    wind_speed: String,\n    #[serde(rename = \"windDirection\")]\n    wind_direction: String,\n    #[serde(rename = \"detailedForecast\")]\n    detailed_forecast: String,\n}\n```\nNow define the request types that MCP clients will send:\nCopy\n```\n#[derive(serde::Deserialize, schemars::JsonSchema)]\npub struct MCPForecastRequest {\n    latitude: f32,\n    longitude: f32,\n}\n#[derive(serde::Deserialize, schemars::JsonSchema)]\npub struct MCPAlertRequest {\n    state: String,\n}\n```\n###\n[​\n](#helper-functions-3)\nHelper functions\nAdd helper functions for making API requests and formatting responses:\nCopy\n```\nasync fn make_nws_request<T: DeserializeOwned>(url: &str) -> Result<T> {\n    let client = reqwest::Client::new();\n    let rsp = client\n        .get(url)\n        .header(reqwest::header::USER_AGENT, USER_AGENT)\n        .header(reqwest::header::ACCEPT, \"application/geo+json\")\n        .send()\n        .await?\n        .error_for_status()?;\n    Ok(rsp.json::<T>().await?)\n}\nfn format_alert(feature: &AlertFeature) -> String {\n    let props = &feature.properties;\n    format!(\n        \"Event: {}\\nArea: {}\\nSeverity: {}\\nDescription: {}\\nInstructions: {}\",\n        props.event.as_deref().unwrap_or(\"Unknown\"),\n        props.area_desc.as_deref().unwrap_or(\"Unknown\"),\n        props.severity.as_deref().unwrap_or(\"Unknown\"),\n        props\n            .description\n            .as_deref()\n            .unwrap_or(\"No description available\"),\n        props\n            .instruction\n            .as_deref()\n            .unwrap_or(\"No specific instructions provided\")\n    )\n}\nfn format_period(period: &ForecastPeriod) -> String {\n    format!(\n        \"{}:\\nTemperature: {}°{}\\nWind: {} {}\\nForecast: {}\",\n        period.name,\n        period.temperature,\n        period.temperature_unit,\n        period.wind_speed,\n        period.wind_direction,\n        period.detailed_forecast\n    )\n}\n```\n###\n[​\n](#implementing-the-weather-server-and-tools)\nImplementing the Weather server and tools\nNow let’s implement the main Weather server struct with the tool handlers:\nCopy\n```\npub struct Weather {\n    tool_router: ToolRouter<Weather>,\n}\n#[tool_router]\nimpl Weather {\n    fn new() -> Self {\n        Self {\n            tool_router: Self::tool_router(),\n        }\n    }\n    #[tool(description = \"Get weather alerts for a US state.\")]\n    async fn get_alerts(\n        &self,\n        Parameters(MCPAlertRequest { state }): Parameters<MCPAlertRequest>,\n    ) -> String {\n        let url = format!(\n            \"{}/alerts/active/area/{}\",\n            NWS_API_BASE,\n            state.to_uppercase()\n        );\n        match make_nws_request::<AlertsResponse>(&url).await {\n            Ok(data) => {\n                if data.features.is_empty() {\n                    \"No active alerts for this state.\".to_string()\n                } else {\n                    data.features\n                        .iter()\n                        .map(format_alert)\n                        .collect::<Vec<_>>()\n                        .join(\"\\n---\\n\")\n                }\n            }\n            Err(_) => \"Unable to fetch alerts or no alerts found.\".to_string(),\n        }\n    }\n    #[tool(description = \"Get weather forecast for a location.\")]\n    async fn get_forecast(\n        &self,\n        Parameters(MCPForecastRequest {\n            latitude,\n            longitude,\n        }): Parameters<MCPForecastRequest>,\n    ) -> String {\n        let points_url = format!(\"{NWS_API_BASE}/points/{latitude},{longitude}\");\n        let Ok(points_data) = make_nws_request::<PointsResponse>(&points_url).await else {\n            return \"Unable to fetch forecast data for this location.\".to_string();\n        };\n        let forecast_url = points_data.properties.forecast;\n        let Ok(forecast_data) = make_nws_request::<ForecastResponse>(&forecast_url).await else {\n            return \"Unable to fetch forecast data for this location.\".to_string();\n        };\n        let periods = &forecast_data.properties.periods;\n        let forecast_summary: String = periods\n            .iter()\n            .take(5) // Next 5 periods only\n            .map(format_period)\n            .collect::<Vec<String>>()\n            .join(\"\\n---\\n\");\n        forecast_summary\n    }\n}\n```\nThe `#[tool_router]` macro automatically generates the routing logic, and the `#[tool]` attribute marks methods as MCP tools.\n###\n[​\n](#implementing-the-serverhandler)\nImplementing the ServerHandler\nImplement the `ServerHandler` trait to define server capabilities:\nCopy\n```\n#[tool_handler]\nimpl ServerHandler for Weather {\n    fn get_info(&self) -> ServerInfo {\n        ServerInfo {\n            capabilities: ServerCapabilities::builder().enable_tools().build(),\n            ..Default::default()\n        }\n    }\n}\n```\n###\n[​\n](#running-the-server-6)\nRunning the server\nFinally, implement the main function to run the server with stdio transport:\nCopy\n```\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let transport = (tokio::io::stdin(), tokio::io::stdout());\n    let service = Weather::new().serve(transport).await?;\n    service.waiting().await?;\n    Ok(())\n}\n```\nBuild your server with:\nCopy\n```\ncargo build --release\n```\nThe compiled binary will be in `target/release/weather`.Let’s now test your server from an existing MCP host, Claude for Desktop.\n##\n[​\n](#testing-your-server-with-claude-for-desktop-6)\nTesting your server with Claude for Desktop\nClaude for Desktop is not yet available on Linux. Linux users can proceed to the [Building a client](https://modelcontextprotocol.io/docs/develop/build-client) tutorial to build an MCP client that connects to the server we just built.\nFirst, make sure you have Claude for Desktop installed. [You can install the latest version here.](https://claude.ai/download) If you already have Claude for Desktop, **make sure it’s updated to the latest version.**We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at `~/Library/Application Support/Claude/claude_desktop_config.json` in a text editor. Make sure to create the file if it doesn’t exist.For example, if you have [VS Code](https://code.visualstudio.com/) installed:\nmacOS/Linux\nWindows\nCopy\n```\ncode ~/Library/Application\\ Support/Claude/claude_desktop_config.json\n```\nYou’ll then add your servers in the `mcpServers` key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.In this case, we’ll add our single weather server like so:\nmacOS/Linux\nWindows\nCopy\n```\n{\n  \"mcpServers\": {\n    \"weather\": {\n      \"command\": \"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/target/release/weather\"\n    }\n  }\n}\n```\nMake sure you pass in the absolute path to your compiled binary. You can get this by running `pwd` on macOS/Linux or `cd` on Windows Command Prompt from your project directory. On Windows, remember to use double backslashes (`\\\\`) or forward slashes (`/`) in the JSON path, and add the `.exe` extension.\nThis tells Claude for Desktop:\n1.  There’s an MCP server named “weather”\n2.  Launch it by running the compiled binary at the specified path\nSave the file, and restart **Claude for Desktop**.\n###\n[​\n](#test-with-commands)\nTest with commands\nLet’s make sure Claude for Desktop is picking up the two tools we’ve exposed in our `weather` server. You can do this by looking for the “Add files, connectors, and more /” ![](https://mintcdn.com/mcp/zNouQwo2h8cbxlDS/images/claude-add-files-connectors-and-more.png?fit=max&auto=format&n=zNouQwo2h8cbxlDS&q=85&s=eb7ecdd7bb5698946f0c6a25284fd988) icon:\n![](https://mintcdn.com/mcp/zNouQwo2h8cbxlDS/images/visual-indicator-mcp-tools.png?fit=max&auto=format&n=zNouQwo2h8cbxlDS&q=85&s=1bf23a2cfc5f6dd3dac1c7574cceebc9)\nAfter clicking on the plus icon, hover over the “Connectors” menu. You should see the `weather` servers listed:\n![](https://mintcdn.com/mcp/zNouQwo2h8cbxlDS/images/available-mcp-tools.png?fit=max&auto=format&n=zNouQwo2h8cbxlDS&q=85&s=e2ace1ac88895a5fe30ebd8d01456bc3)\nIf your server isn’t being picked up by Claude for Desktop, proceed to the [Troubleshooting](#troubleshooting) section for debugging tips. If the server has shown up in the “Connectors” menu, you can now test your server by running the following commands in Claude for Desktop:\n-   What’s the weather in Sacramento?\n-   What are the active weather alerts in Texas?\n![](https://mintcdn.com/mcp/4ZXF1PrDkEaJvXpn/images/current-weather.png?fit=max&auto=format&n=4ZXF1PrDkEaJvXpn&q=85&s=dce7b2f8a06c20ba358e4bd2e75fa4c7)\n![](https://mintcdn.com/mcp/4ZXF1PrDkEaJvXpn/images/weather-alerts.png?fit=max&auto=format&n=4ZXF1PrDkEaJvXpn&q=85&s=c4762bf2bd84a8781846d2965af3e4a4)\nSince this is the US National Weather service, the queries will only work for US locations.\n##\n[​\n](#what’s-happening-under-the-hood)\nWhat’s happening under the hood\nWhen you ask a question:\n1.  The client sends your question to Claude\n2.  Claude analyzes the available tools and decides which one(s) to use\n3.  The client executes the chosen tool(s) through the MCP server\n4.  The results are sent back to Claude\n5.  Claude formulates a natural language response\n6.  The response is displayed to you!\n##\n[​\n](#troubleshooting)\nTroubleshooting\nClaude for Desktop Integration Issues\n**Getting logs from Claude for Desktop**Claude.app logging related to MCP is written to log files in `~/Library/Logs/Claude`:\n-   `mcp.log` will contain general logging about MCP connections and connection failures.\n-   Files named `mcp-server-SERVERNAME.log` will contain error (stderr) logging from the named server.\nYou can run the following command to list recent logs and follow along with any new ones:\nCopy\n```\n# Check Claude's logs for errors\ntail -n 20 -f ~/Library/Logs/Claude/mcp*.log\n```\n**Server not showing up in Claude**\n1.  Check your `claude_desktop_config.json` file syntax\n2.  Make sure the path to your project is absolute and not relative\n3.  Restart Claude for Desktop completely\nTo properly restart Claude for Desktop, you must fully quit the application:\n-   **Windows**: Right-click the Claude icon in the system tray (which may be hidden in the “hidden icons” menu) and select “Quit” or “Exit”.\n-   **macOS**: Use Cmd+Q or select “Quit Claude” from the menu bar.\nSimply closing the window does not fully quit the application, and your MCP server configuration changes will not take effect.\n**Tool calls failing silently**If Claude attempts to use the tools but they fail:\n1.  Check Claude’s logs for errors\n2.  Verify your server builds and runs without errors\n3.  Try restarting Claude for Desktop\n**None of this is working. What do I do?**Please refer to our [debugging guide](https://modelcontextprotocol.io/legacy/tools/debugging) for better debugging tools and more detailed guidance.\nWeather API Issues\n**Error: Failed to retrieve grid point data**This usually means either:\n1.  The coordinates are outside the US\n2.  The NWS API is having issues\n3.  You’re being rate limited\nFix:\n-   Verify you’re using US coordinates\n-   Add a small delay between requests\n-   Check the NWS API status page\n**Error: No active alerts for \\[STATE\\]**This isn’t an error - it just means there are no current weather alerts for that state. Try a different state or check during severe weather.\nFor more advanced troubleshooting, check out our guide on [Debugging MCP](https://modelcontextprotocol.io/legacy/tools/debugging)\n##\n[​\n](#next-steps)\nNext steps\n[\n## Building a client\nLearn how to build your own MCP client that can connect to your server\n](https://modelcontextprotocol.io/docs/develop/build-client)[\n## Example servers\nCheck out our gallery of official MCP servers and implementations\n](https://modelcontextprotocol.io/examples)[\n## Debugging Guide\nLearn how to effectively debug MCP servers and integrations\n](https://modelcontextprotocol.io/legacy/tools/debugging)[\n## Building MCP with LLMs\nLearn how to use LLMs like Claude to speed up your MCP development\n](https://modelcontextprotocol.io/tutorials/building-mcp-with-llms)\nWas this page helpful?\nYesNo\n[Connect to remote MCP Servers](https://modelcontextprotocol.io/docs/develop/connect-remote-servers)[Build an MCP client](https://modelcontextprotocol.io/docs/develop/build-client)\n⌘I\n[github](https://github.com/modelcontextprotocol)",
  "timestamp": 1769084277768,
  "title": "Build an MCP server - Model Context Protocol"
}