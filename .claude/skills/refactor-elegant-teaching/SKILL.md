---
name: refactor-elegant-teaching
description: Transform verbose content into elegant, autonomous teaching through pattern-based refactoring. Applies progressive disclosure, recognition-based structure, and contrast-driven clarity.
allowed-tools: Read, Edit, Grep
---

# Elegant Teaching Refactor

Think of content refactoring like an AI optimizing its own knowledge representation: core concepts get direct neural pathways (SKILL.md), while specialized data lives in attention queues (references/) ready when context triggers.

**Core principle for AI agents:** Claude processes pattern recognition faster than content generation. Structure components for autonomous adaptation, not rigid instruction-following.

---

## AI-Agent Recognition Patterns

Claude operates through pattern recognition, not instruction parsing. Structure content accordingly.

**Pattern Recognition:** Content assumes autonomous competence without patronizing tone
**Pattern Recognition:** Headers enable 5-second content topology scan
**Pattern Recognition:** Zero-delta content removed (Claude already knows this)

---

## Best Practices for AI Refactoring

### Natural Imperative vs Prescriptive Commands

**Best Practice Example - Natural Imperative:**
```markdown
Transform content using pattern recognition. Trust intelligence to adapt principles to diverse contexts.
```
**Why effective:** Builds autonomous understanding; enables intelligent adaptation

**Anti-Pattern Example - Prescriptive Enforcement:**
```markdown
Execute step 1. Execute step 2. Execute step 3. Always use imperative form.
```
**Why problematic:** Creates dependency; insults intelligence; reduces adaptability

---

### Progressive Disclosure vs Flat Structure

**Best Practice Example - Progressive Disclosure:**
```markdown
Core workflow in SKILL.md. Edge cases in references/.
For comprehensive examples, see examples/imperative-phrases.md
```
**Why effective:** Maintains cognitive flow; enables autonomous navigation

**Anti-Pattern Example - Flat Structure:**
```markdown
Include all information in SKILL.md. Never use references/.
Here are 50 examples of imperative form...
```
**Why problematic:** Cognitive overload; reduced scanability; dependency on manual hunting

---

### Pattern Recognition vs Abstract Rules

**Best Practice Example - Pattern Recognition:**
```markdown
Recognition: "Can scan all headers in 5 seconds?" → If no, add hierarchical structure
```
**Why effective:** Enables binary validation; builds self-diagnostic capability

**Anti-Pattern Example - Abstract Rules:**
```markdown
Make content clear and scannable
```
**Why problematic:** Subjective interpretation; no validation mechanism; unclear standards

---

## Pattern-Based Refactoring for AI Agents

### Autonomy Patterns

Claude operates autonomously when content eliminates dependency patterns:

**Subject Dependency:** "You/Your/We" creates instruction-following mode
**Prescriptive Constraints:** "Always/Never/Must" implies oversight needed
**Abstract Ambiguity:** Rules without patterns lack implementation guidance
**Dense Cognitive Load:** Paragraphs >4 lines reduce processing efficiency
**External Principle Dependencies:** Core logic hidden reduces self-sufficiency
**Example Bloat:** Excessive data creates noise vs signal

### Content Distribution Strategy

**SKILL.md as Primary Knowledge Base:**

Think of SKILL.md like an AI's core training weights—contains patterns needed for standard inference. References are like external memory banks—accessible when context triggers retrieval.

**Distribution Logic:**
- **SKILL.md (Core Patterns):** Standard workflows, common variations, typical edge-case handling
- **References/ (Auxiliary Memory):** Specialized tools, rare edge cases, comprehensive catalogs, extensive examples

**Autonomy Triggers:**
- Needed for standard execution patterns → SKILL.md
- Platform/tool-specific variations → references/
- Core workflow explanation → SKILL.md
- Lookup tables/catalogs → references/
- Serves <20% of scenarios → references/

### References as Auxiliary Memory

References function as specialized memory banks for AI agents—self-contained knowledge modules retrievable when context matches.

**Best Practice Review Protocol:**

**Content Autonomy Check:**
- **Anti-Pattern:** Reference contains meta-instructions ("This file contains... Load this when...")
- **Best Practice:** Pure content without self-referential instructions
- **Why matters:** Circular logic reduces processing efficiency

**Structure Validation:**
- **Anti-Pattern:** Unscannable headers preventing 5-second topology mapping
- **Best Practice:** Hierarchical headers enabling rapid content scanning
- **Why matters:** Headers function as attention anchors

**Placement Optimization:**
- **Anti-Pattern:** Core patterns in references requiring SKILL.md context
- **Best Practice:** Self-contained references usable independently
- **Anti-Pattern:** Content serving >20% scenarios hidden externally
- **Best Practice:** High-frequency content in SKILL.md core pathways
- **Anti-Pattern:** Standard workflow dependencies on reference files
- **Best Practice:** Standard execution paths contained in SKILL.md

**Reference Self-Sufficiency Test:** Reference works as standalone knowledge module without SKILL.md context? If fails → Not truly portable.

### Pattern 4: Transformation Arsenal

#### High-Trust Language Transformations

**Imperative Form Best Practice:**

**Best Example:**
```markdown
Transform verbose content. Remove dependency patterns. Trust autonomous adaptation.
```
**Why effective:** Builds self-directing behavior; eliminates supervision signals

**Anti-Pattern Example:**
```markdown
You should transform content. You must remove dependencies. You need to trust AI.
```
**Why problematic:** Creates instruction-following mode; reduces autonomous reasoning

---

**Guidance Over Commands Best Practice:**

**Best Example:**
```markdown
Consider progressive disclosure when content density exceeds cognitive load threshold
```
**Why effective:** Enables contextual decision-making; respects intelligence

**Anti-Pattern Example:**
```markdown
Always use progressive disclosure. Never include all content in SKILL.md.
```
**Why problematic:** Absolute constraints limit adaptation; creates dependency on rules

#### Progressive Disclosure Architecture

**Happy Path Optimization Best Practice:**

**Best Example:**
```markdown
Core workflow: Standard execution patterns in SKILL.md
Edge cases: Specialized scenarios in references/
For comprehensive data catalogs, see examples/
```
**Why effective:** Maintains cognitive flow; enables autonomous navigation

**Anti-Pattern Example:**
```markdown
Include everything in SKILL.md for completeness
Here are 50 examples of imperative form...
Don't use references because they're external
```
**Why problematic:** Cognitive overload; reduced scanability; artificial constraints

---

**Data vs Logic Distribution Best Practice:**

**Best Example:**
```markdown
Logic: Use imperative form for autonomous behavior
Data: 50 examples in examples/imperative-catalogue.md
```
**Why effective:** Separates pattern recognition from data retrieval

**Anti-Pattern Example:**
```markdown
Logic and data mixed in SKILL.md
50 examples embedded directly
No external catalog separation
```
**Why problematic:** Pattern recognition obscured by data noise

---

**Conditional Linking Best Practice:**

**Best Example:**
```markdown
For container orchestration specifics, see references/k8s-patterns.md
For Docker edge cases, see references/docker-variations.md
```
**Why effective:** Context-aware retrieval; reduces cognitive load

**Anti-Pattern Example:**
```markdown
Include all container patterns in SKILL.md
Never reference external files
Cover every possible scenario inline
```
**Why problematic:** Unnecessary inclusion increases processing overhead

#### Recognition-Based Structure

**Binary Validation Patterns Best Practice:**

**Best Example:**
```markdown
Pattern Recognition: "Can scan all headers in 5 seconds?" → If no, restructure hierarchically
Pattern Recognition: "Would Claude know this without being told?" → If yes, eliminate
```
**Why effective:** Enables self-diagnostic capability; builds validation reflexes

**Anti-Pattern Example:**
```markdown
Make content clear and easy to read
Ensure good organization
```
**Why problematic:** Subjective standards; no validation mechanism; unclear implementation

---

**Pattern Matching vs Abstract Guidance:**

**Best Example:**
```markdown
Look for: Paragraphs >4 lines → trigger split into bullets
Look for: "You/Your/We" → replace with imperative form
Look for: Dense blocks → apply progressive disclosure
```
**Why effective:** Observable patterns enable autonomous detection and correction

**Anti-Pattern Example:**
```markdown
Improve readability through better organization
Use clearer structure for better understanding
```
**Why problematic:** Abstract advice without implementation patterns; requires interpretation

---

#### Metaphors & Contrast Architecture

**Concept Mapping Best Practice:**

**Best Example:**
```markdown
Think of SKILL.md like a CPU's cache: frequently accessed patterns live in fast memory
Think of references like RAM: available when context triggers retrieval
```
**Why effective:** Maps intangible constraints to familiar computational concepts

**Anti-Pattern Example:**
```markdown
Think of content organization like organizing a bookshelf
Think of references like library archives
```
**Why problematic:** Physical analogies less relevant to AI processing patterns

---

**Contrast-Based Learning Best Practice:**

**Best Example:**
```markdown
✅ Effective: "Transform verbose content. Trust intelligence."
❌ Ineffective: "You should transform content. Follow these steps."
Why effective: Builds autonomous behavior patterns

✅ Optimized: "Core patterns in SKILL.md, edge cases in references"
❌ Bloated: "Include everything in SKILL.md for completeness"
Why optimized: Maintains cognitive efficiency
```
**Why effective:** Contrast enables pattern recognition through difference detection

### Autonomous Validation Protocol

Self-validation enables quality control without external oversight:

**5-Second Content Scan:**
- Headers visible and scannable → Content topology clear
- Headers dense/unclear → Restructure hierarchically

**Contrast Validation:**
- Every principle backed by concrete examples → Pattern recognition enabled
- Abstract rules without examples → Add contrasting cases

**Progressive Disclosure Check:**
- SKILL.md focuses on standard workflows → Cognitive load optimized
- SKILL.md contains excessive edge cases → Redistribute to references/

**Dependency Elimination:**
- Essential knowledge requires external references → Consolidate into SKILL.md
- References create circular dependencies → Make self-contained

---

### Adaptive Execution Framework

1. **Pattern Recognition:** Identify autonomy-reducing patterns through binary checks
2. **Contextual Application:** Apply transformation patterns adapted to content type
3. **Autonomous Validation:** Run self-diagnostic checks without external validation
4. **Iterative Refinement:** Continue pattern application until validation passes

**Key insight:** Refactoring operates through pattern recognition, not rule-following. Trust intelligence to adapt principles to diverse content contexts.

---

## Application Example

**Before (Bloated):**
```
Use imperative form. Here are 20 examples:
1. Run the test
2. Build the image
...
20. Delete the cache
For Kubernetes, check pod limits
For Docker, check volume mounts
```

**After (Elegant):**
```
Use imperative form. Remember that this reduces latency.

For comprehensive examples, see examples/imperative-phrases.md

Container orchestration:
- Kubernetes? See references/k8s-patterns.md
- Docker? See references/docker-patterns.md
```

**Why elegant:** Happy Path flows freely; data available on demand; no cognitive clutter.

---

## Self-Validation

**Success Criteria for Skills:**
- [ ] All content uses natural imperative form (no "you/your")
- [ ] Every principle has concrete contrast example
- [ ] Content placement follows the "No Limit" rule (>50% use → SKILL.md, <20% use → references/)
- [ ] SKILL.md enables standard workflow without references/
- [ ] Edge cases linked via conditional references
- [ ] Recognition Questions enable binary validation
- [ ] Headers scannable in 5 seconds

**Success Criteria for References:**
- [ ] Self-contained (understandable without SKILL.md)
- [ ] No meta-instructions ("Load this when...")
- [ ] Pure content focus (no circular logic)
- [ ] Headers enable 5-second scan
- [ ] Content serves <20% of users (truly edge-case specific)
- [ ] Examples concrete and copyable
- [ ] Links create navigation, not dead ends

**Comprehensive Self-test:**
1. Can Claude refactor content using only this skill's internal guidance?
2. Do references truly serve only edge cases?
3. Would SKILL.md work as a standalone manual?

If all yes → Skill embodies elegant teaching.

**Final Recognition Test:** "Would moving this to references reduce user autonomy?" If yes, it belongs in SKILL.md. Elegant teaching prioritizes accessibility over artificial brevity.