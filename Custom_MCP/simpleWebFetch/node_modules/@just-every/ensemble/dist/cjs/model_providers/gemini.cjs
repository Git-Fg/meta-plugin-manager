"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.geminiProvider = exports.GeminiProvider = void 0;
exports.getImageMimeType = getImageMimeType;
exports.cleanBase64Data = cleanBase64Data;
const genai_1 = require("@google/genai");
const uuid_1 = require("uuid");
const base_provider_js_1 = require("./base_provider.cjs");
const cost_tracker_js_1 = require("../utils/cost_tracker.cjs");
const llm_logger_js_1 = require("../utils/llm_logger.cjs");
const pause_controller_js_1 = require("../utils/pause_controller.cjs");
const image_utils_js_1 = require("../utils/image_utils.cjs");
const event_controller_js_1 = require("../utils/event_controller.cjs");
const truncate_utils_js_1 = require("../utils/truncate_utils.cjs");
function convertParameterToGeminiFormat(param) {
    let type = genai_1.Type.STRING;
    switch (param.type) {
        case 'string':
            type = genai_1.Type.STRING;
            break;
        case 'number':
            type = genai_1.Type.NUMBER;
            break;
        case 'boolean':
            type = genai_1.Type.BOOLEAN;
            break;
        case 'object':
            type = genai_1.Type.OBJECT;
            break;
        case 'array':
            type = genai_1.Type.ARRAY;
            break;
        case 'null':
            type = genai_1.Type.STRING;
            console.warn("Mapping 'null' type to STRING");
            break;
        default:
            console.warn(`Unsupported parameter type '${param.type}'. Defaulting to STRING.`);
            type = genai_1.Type.STRING;
    }
    const result = { type, description: param.description };
    if (type === genai_1.Type.ARRAY) {
        if (param.items) {
            let itemType;
            let itemEnum;
            let itemProperties;
            if (typeof param.items === 'object') {
                itemType = param.items.type;
                itemEnum = param.items.enum;
                if ('properties' in param.items) {
                    itemProperties = param.items.properties;
                }
            }
            if (itemType === 'object' || itemProperties) {
                result.items = { type: genai_1.Type.STRING };
                result.description = `${result.description || 'Array parameter'} (Each item should be a JSON-encoded object)`;
                if (itemProperties) {
                    const propNames = Object.keys(itemProperties);
                    result.description += `. Expected properties: ${propNames.join(', ')}`;
                }
            }
            else if (itemType) {
                result.items = {
                    type: itemType === 'string'
                        ? genai_1.Type.STRING
                        : itemType === 'number'
                            ? genai_1.Type.NUMBER
                            : itemType === 'boolean'
                                ? genai_1.Type.BOOLEAN
                                : itemType === 'null'
                                    ? genai_1.Type.STRING
                                    : genai_1.Type.STRING,
                };
                if (itemEnum) {
                    if (typeof itemEnum === 'function') {
                        console.warn('Gemini provider does not support async enum functions in array items');
                    }
                    else {
                        result.items.enum = itemEnum;
                    }
                }
            }
            else {
                result.items = { type: genai_1.Type.STRING };
            }
        }
        else {
            result.items = { type: genai_1.Type.STRING };
        }
    }
    else if (type === genai_1.Type.OBJECT) {
        if (param.properties && typeof param.properties === 'object') {
            result.properties = {};
            for (const [propName, propSchema] of Object.entries(param.properties)) {
                result.properties[propName] = convertParameterToGeminiFormat(propSchema);
            }
        }
        else {
            result.properties = {};
        }
    }
    else if (param.enum) {
        if (typeof param.enum === 'function') {
            console.warn('Gemini provider does not support async enum functions. Enum will be omitted.');
        }
        else {
            result.format = 'enum';
            result.enum = param.enum;
        }
    }
    return result;
}
async function resolveAsyncEnums(params) {
    if (!params || typeof params !== 'object') {
        return params;
    }
    const resolved = { ...params };
    if (resolved.properties) {
        const resolvedProps = {};
        for (const [key, value] of Object.entries(resolved.properties)) {
            if (value && typeof value === 'object') {
                const propCopy = { ...value };
                if (typeof propCopy.enum === 'function') {
                    try {
                        const enumValue = await propCopy.enum();
                        if (Array.isArray(enumValue) && enumValue.length > 0) {
                            propCopy.enum = enumValue;
                        }
                        else {
                            delete propCopy.enum;
                        }
                    }
                    catch {
                        delete propCopy.enum;
                    }
                }
                resolvedProps[key] = await resolveAsyncEnums(propCopy);
            }
            else {
                resolvedProps[key] = value;
            }
        }
        resolved.properties = resolvedProps;
    }
    return resolved;
}
async function convertToGeminiFunctionDeclarations(tools) {
    const declarations = await Promise.all(tools.map(async (tool) => {
        if (tool.definition.function.name === 'google_web_search') {
            return null;
        }
        const resolvedParams = await resolveAsyncEnums(tool.definition?.function?.parameters);
        const toolParams = resolvedParams?.properties;
        const properties = {};
        if (toolParams) {
            for (const [name, param] of Object.entries(toolParams)) {
                properties[name] = convertParameterToGeminiFormat(param);
            }
        }
        else {
            console.warn(`Tool ${tool.definition?.function?.name || 'Unnamed Tool'} has missing or invalid parameters definition.`);
        }
        return {
            name: tool.definition.function.name,
            description: tool.definition.function.description,
            parameters: {
                type: genai_1.Type.OBJECT,
                properties,
                required: Array.isArray(resolvedParams?.required) ? resolvedParams.required : [],
            },
        };
    }));
    return declarations.filter(Boolean);
}
function getImageMimeType(imageData) {
    if (imageData.includes('data:image/png'))
        return 'image/png';
    if (imageData.includes('data:image/jpeg'))
        return 'image/jpeg';
    if (imageData.includes('data:image/gif'))
        return 'image/gif';
    if (imageData.includes('data:image/webp'))
        return 'image/webp';
    return 'image/png';
}
function inferImageMimeTypeFromUrl(src) {
    try {
        const url = new URL(src);
        const path = url.pathname.toLowerCase();
        if (path.endsWith('.png'))
            return 'image/png';
        if (path.endsWith('.jpg') || path.endsWith('.jpeg'))
            return 'image/jpeg';
        if (path.endsWith('.webp'))
            return 'image/webp';
        if (path.endsWith('.gif'))
            return 'image/gif';
        if (path.endsWith('.bmp'))
            return 'image/bmp';
        if (path.endsWith('.tif') || path.endsWith('.tiff'))
            return 'image/tiff';
        if (path.endsWith('.svg'))
            return 'image/svg+xml';
    }
    catch {
    }
    const lower = src.toLowerCase();
    if (lower.includes('.png'))
        return 'image/png';
    if (lower.includes('.jpg') || lower.includes('.jpeg'))
        return 'image/jpeg';
    if (lower.includes('.webp'))
        return 'image/webp';
    if (lower.includes('.gif'))
        return 'image/gif';
    if (lower.includes('.bmp'))
        return 'image/bmp';
    if (lower.includes('.tif') || lower.includes('.tiff'))
        return 'image/tiff';
    if (lower.includes('.svg'))
        return 'image/svg+xml';
    return 'image/jpeg';
}
function cleanBase64Data(imageData) {
    return imageData.replace(/^data:image\/[a-z]+;base64,/, '');
}
function formatGroundingChunks(chunks) {
    return chunks
        .filter(c => c?.web?.uri)
        .map((c, i) => `${i + 1}. ${c.web.title || 'Untitled'} â€“ ${c.web.uri}`)
        .join('\n');
}
async function addImagesToInput(input, images, source) {
    for (const [image_id, imageData] of Object.entries(images)) {
        const processedImageData = await (0, image_utils_js_1.resizeAndTruncateForGemini)(imageData);
        const mimeType = getImageMimeType(processedImageData);
        const cleanedImageData = cleanBase64Data(processedImageData);
        input.push({
            role: 'user',
            parts: [
                {
                    text: `[image #${image_id}] from the ${source}`,
                },
                {
                    inlineData: {
                        mimeType: mimeType,
                        data: cleanedImageData,
                    },
                },
            ],
        });
    }
    return input;
}
async function convertToGeminiContents(model, messages) {
    let contents = [];
    for (const msg of messages) {
        if (msg.type === 'function_call') {
            let args = {};
            try {
                const parsedArgs = JSON.parse(msg.arguments || '{}');
                args = typeof parsedArgs === 'object' && parsedArgs !== null ? parsedArgs : { value: parsedArgs };
            }
            catch (e) {
                console.error(`Failed to parse function call arguments for ${msg.name}:`, (0, truncate_utils_js_1.truncateLargeValues)(msg.arguments), e);
                args = {
                    error: 'Invalid JSON arguments provided',
                    raw_args: msg.arguments,
                };
            }
            contents.push({
                role: 'model',
                parts: [
                    {
                        functionCall: {
                            name: msg.name,
                            args,
                        },
                    },
                ],
            });
        }
        else if (msg.type === 'function_call_output') {
            let textOutput = '';
            if (typeof msg.output === 'string') {
                textOutput = msg.output;
            }
            else {
                textOutput = JSON.stringify(msg.output);
            }
            const message = {
                role: 'user',
                parts: [
                    {
                        functionResponse: {
                            name: msg.name,
                            response: { content: textOutput || '' },
                        },
                    },
                ],
            };
            contents = await (0, image_utils_js_1.appendMessageWithImage)(model, contents, message, {
                read: () => textOutput,
                write: value => {
                    message.parts[0].functionResponse.response.content = value;
                    return message;
                },
            }, addImagesToInput);
        }
        else {
            const role = msg.role === 'assistant' ? 'model' : 'user';
            if (Array.isArray(msg.content)) {
                const parts = [];
                for (const item of msg.content) {
                    if (item.type === 'input_text') {
                        parts.push({
                            thought: msg.type === 'thinking',
                            text: item.text || '',
                        });
                    }
                    else if (item.type === 'input_image' || item.type === 'image') {
                        const normalized = (0, image_utils_js_1.normalizeImageDataUrl)({
                            data: 'data' in item ? item.data : undefined,
                            image_url: 'image_url' in item ? item.image_url : undefined,
                            url: 'url' in item ? item.url : undefined,
                            mime_type: 'mime_type' in item ? item.mime_type : undefined,
                        });
                        const imageUrl = normalized.dataUrl || normalized.url || ('image_url' in item ? item.image_url : '');
                        if (imageUrl.startsWith('data:')) {
                            const match = imageUrl.match(/^data:([^;]+);base64,(.+)$/);
                            if (match) {
                                const mimeType = match[1];
                                const base64Data = match[2];
                                const processedData = await (0, image_utils_js_1.resizeAndTruncateForGemini)(imageUrl);
                                const processedMatch = processedData.match(/^data:([^;]+);base64,(.+)$/);
                                if (processedMatch) {
                                    parts.push({
                                        inlineData: {
                                            mimeType: processedMatch[1],
                                            data: processedMatch[2],
                                        },
                                    });
                                }
                                else {
                                    parts.push({
                                        inlineData: {
                                            mimeType: mimeType,
                                            data: base64Data,
                                        },
                                    });
                                }
                            }
                        }
                        else if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                            parts.push({
                                fileData: {
                                    mimeType: inferImageMimeTypeFromUrl(imageUrl),
                                    fileUri: imageUrl,
                                },
                            });
                        }
                    }
                }
                if (parts.length > 0) {
                    const message = { role, parts };
                    contents.push(message);
                }
            }
            else {
                let textContent = '';
                if (typeof msg.content === 'string') {
                    textContent = msg.content;
                }
                else {
                    textContent = JSON.stringify(msg.content);
                }
                const message = {
                    role,
                    parts: [
                        {
                            thought: msg.type === 'thinking',
                            text: textContent.trim(),
                        },
                    ],
                };
                contents = await (0, image_utils_js_1.appendMessageWithImage)(model, contents, message, {
                    read: () => textContent,
                    write: value => {
                        message.parts[0].text = value;
                        return message;
                    },
                }, addImagesToInput);
            }
        }
    }
    return contents;
}
const THINKING_BUDGET_CONFIGS = {
    '-low': 0,
    '-medium': 2048,
    '-high': 12288,
    '-max': 24576,
};
class GeminiProvider extends base_provider_js_1.BaseModelProvider {
    _client;
    apiKey;
    constructor(apiKey) {
        super('google');
        this.apiKey = apiKey;
    }
    get client() {
        if (!this._client) {
            const apiKey = this.apiKey || process.env.GOOGLE_API_KEY;
            if (!apiKey) {
                throw new Error('Failed to initialize Gemini client. GOOGLE_API_KEY is missing or not provided.');
            }
            this._client = new genai_1.GoogleGenAI({
                apiKey: apiKey,
                vertexai: false,
                httpOptions: { apiVersion: 'v1beta' },
            });
        }
        return this._client;
    }
    async createEmbedding(input, model, agent, opts) {
        const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
        let finalRequestId = requestId;
        try {
            let actualModelId = model.startsWith('gemini/') ? model.substring(7) : model;
            let thinkingConfig = null;
            for (const [suffix, budget] of Object.entries(THINKING_BUDGET_CONFIGS)) {
                if (actualModelId.endsWith(suffix)) {
                    thinkingConfig = { thinkingBudget: budget };
                    actualModelId = actualModelId.slice(0, -suffix.length);
                    break;
                }
            }
            console.log(`[Gemini] Generating embedding with model ${actualModelId}${opts?.dimensions ? ` (dimensions: ${opts.dimensions})` : ''}`);
            const payload = {
                model: actualModelId,
                contents: input,
                config: {
                    taskType: opts?.taskType ?? 'SEMANTIC_SIMILARITY',
                    ...(opts?.dimensions && { outputDimensionality: opts.dimensions }),
                },
            };
            if (thinkingConfig) {
                payload.config.thinkingConfig = thinkingConfig;
            }
            const loggedRequestId = (0, llm_logger_js_1.log_llm_request)(agent.agent_id || 'default', 'gemini', actualModelId, {
                ...payload,
                input_length: Array.isArray(input) ? input.length : 1,
            }, new Date(), requestId, agent.tags);
            finalRequestId = loggedRequestId;
            const response = await this.client.models.embedContent(payload);
            console.log('[Gemini] Embedding response structure:', JSON.stringify(response, (key, value) => key === 'values' && Array.isArray(value) && value.length > 10
                ? `[${value.length} items]`
                : value, 2));
            if (!response.embeddings || !Array.isArray(response.embeddings)) {
                console.error('[Gemini] Unexpected embedding response structure:', (0, truncate_utils_js_1.truncateLargeValues)(response));
                throw new Error('Invalid embedding response structure from Gemini API');
            }
            const estimatedTokens = typeof input === 'string'
                ? Math.ceil(input.length / 4)
                : input.reduce((sum, text) => sum + Math.ceil(text.length / 4), 0);
            let extractedValues = [];
            let dimensions = 0;
            if (response.embeddings.length > 0) {
                if (response.embeddings[0].values) {
                    extractedValues = response.embeddings.map(e => e.values);
                    dimensions = extractedValues[0].length;
                }
                else {
                    console.warn('[Gemini] Could not find expected "values" property in embeddings response');
                    extractedValues = response.embeddings;
                    dimensions = Array.isArray(extractedValues[0]) ? extractedValues[0].length : 0;
                }
            }
            cost_tracker_js_1.costTracker.addUsage({
                model: actualModelId,
                input_tokens: estimatedTokens,
                output_tokens: 0,
                metadata: {
                    dimensions,
                },
            });
            (0, llm_logger_js_1.log_llm_response)(finalRequestId, {
                model: actualModelId,
                dimensions,
                vector_count: extractedValues.length,
                estimated_tokens: estimatedTokens,
            });
            if (Array.isArray(input) && input.length > 1) {
                return extractedValues;
            }
            else {
                let result;
                if (Array.isArray(extractedValues) && extractedValues.length >= 1) {
                    const firstValue = extractedValues[0];
                    if (Array.isArray(firstValue)) {
                        result = firstValue;
                    }
                    else {
                        console.error('[Gemini] Unexpected format in embedding result:', (0, truncate_utils_js_1.truncateLargeValues)(firstValue));
                        result = [];
                    }
                }
                else {
                    result = [];
                }
                return result;
            }
        }
        catch (error) {
            (0, llm_logger_js_1.log_llm_error)(finalRequestId, error);
            console.error('[Gemini] Error generating embedding:', (0, truncate_utils_js_1.truncateLargeValues)(error));
            throw error;
        }
    }
    async *retryStreamOnIncompleteJson(requestFn, maxRetries = 2) {
        let attempts = 0;
        while (attempts <= maxRetries) {
            try {
                const stream = await requestFn();
                for await (const chunk of stream) {
                    yield chunk;
                }
                return;
            }
            catch (error) {
                attempts++;
                const errorMsg = error instanceof Error ? error.message : String(error);
                if (errorMsg.includes('Incomplete JSON segment') && attempts <= maxRetries) {
                    console.warn(`[Gemini] Incomplete JSON segment error, retrying (${attempts}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
                    continue;
                }
                throw error;
            }
        }
    }
    async *createResponseStream(messages, model, agent, requestId) {
        const { getToolsFromAgent } = await Promise.resolve().then(() => __importStar(require("../utils/agent.cjs")));
        const tools = agent ? await getToolsFromAgent(agent) : [];
        const settings = agent?.modelSettings;
        let messageId = (0, uuid_1.v4)();
        let contentBuffer = '';
        let thoughtBuffer = '';
        let eventOrder = 0;
        const shownGrounding = new Set();
        const withRequestId = (event) => {
            return requestId ? { ...event, request_id: requestId } : event;
        };
        const chunks = [];
        try {
            const contents = await convertToGeminiContents(model, messages);
            if (contents.length === 0) {
                console.warn('Gemini API Warning: No valid content found in messages after conversion. Adding default message.');
                contents.push({
                    role: 'user',
                    parts: [
                        {
                            text: "Let's think this through step by step.",
                        },
                    ],
                });
            }
            const lastContent = contents[contents.length - 1];
            if (lastContent.role !== 'user') {
                console.warn("Last message in history is not from 'user'. Gemini might not respond as expected.");
            }
            let thinkingBudget = null;
            for (const [suffix, budget] of Object.entries(THINKING_BUDGET_CONFIGS)) {
                if (model.endsWith(suffix)) {
                    thinkingBudget = budget;
                    model = model.slice(0, -suffix.length);
                    break;
                }
            }
            const config = {
                thinkingConfig: {
                    includeThoughts: true,
                },
            };
            if (thinkingBudget) {
                config.thinkingConfig.thinkingBudget = thinkingBudget;
            }
            if (settings?.stop_sequence) {
                config.stopSequences = [settings.stop_sequence];
            }
            if (settings?.temperature) {
                config.temperature = settings.temperature;
            }
            if (settings?.max_tokens) {
                config.maxOutputTokens = settings.max_tokens;
            }
            if (settings?.top_p) {
                config.topP = settings.top_p;
            }
            if (settings?.top_k) {
                config.topK = settings.top_k;
            }
            if (settings?.json_schema) {
                config.responseMimeType = 'application/json';
                config.responseSchema = settings.json_schema.schema;
                if (config.responseSchema) {
                    const removeAdditionalProperties = (obj) => {
                        if (!obj || typeof obj !== 'object') {
                            return;
                        }
                        if ('additionalProperties' in obj) {
                            delete obj.additionalProperties;
                        }
                        if (obj.properties && typeof obj.properties === 'object') {
                            Object.values(obj.properties).forEach(prop => {
                                removeAdditionalProperties(prop);
                            });
                        }
                        if (obj.items) {
                            removeAdditionalProperties(obj.items);
                        }
                        ['oneOf', 'anyOf', 'allOf'].forEach(key => {
                            if (obj[key] && Array.isArray(obj[key])) {
                                obj[key].forEach((subSchema) => {
                                    removeAdditionalProperties(subSchema);
                                });
                            }
                        });
                    };
                    removeAdditionalProperties(config.responseSchema);
                }
            }
            let hasGoogleWebSearch = false;
            let functionDeclarations = [];
            if (tools && tools.length > 0) {
                hasGoogleWebSearch = tools.some(tool => tool.definition.function.name === 'google_web_search');
                functionDeclarations = await convertToGeminiFunctionDeclarations(tools);
                let allowedFunctionNames = [];
                if (functionDeclarations.length > 0) {
                    config.tools = [{ functionDeclarations }];
                    if (settings?.tool_choice) {
                        let toolChoice;
                        if (typeof settings.tool_choice === 'object' &&
                            settings.tool_choice?.type === 'function' &&
                            settings.tool_choice?.function?.name) {
                            toolChoice = genai_1.FunctionCallingConfigMode.ANY;
                            allowedFunctionNames = [settings.tool_choice.function.name];
                        }
                        else if (settings.tool_choice === 'required') {
                            toolChoice = genai_1.FunctionCallingConfigMode.ANY;
                        }
                        else if (settings.tool_choice === 'auto') {
                            toolChoice = genai_1.FunctionCallingConfigMode.AUTO;
                        }
                        else if (settings.tool_choice === 'none') {
                            toolChoice = genai_1.FunctionCallingConfigMode.NONE;
                        }
                        if (toolChoice) {
                            config.toolConfig = {
                                functionCallingConfig: {
                                    mode: toolChoice,
                                },
                            };
                            if (allowedFunctionNames.length > 0) {
                                config.toolConfig.functionCallingConfig.allowedFunctionNames = allowedFunctionNames;
                            }
                        }
                    }
                }
                else if (!hasGoogleWebSearch) {
                    console.warn('Tools were provided but resulted in empty declarations after conversion.');
                }
            }
            if (hasGoogleWebSearch) {
                console.log('[Gemini] Enabling Google Search grounding');
                const toolGroups = [{ googleSearch: {} }];
                if (functionDeclarations.length > 0) {
                    toolGroups.push({ functionDeclarations });
                }
                config.tools = toolGroups;
                if (functionDeclarations.length === 0) {
                    delete config.toolConfig;
                }
            }
            const requestParams = {
                model,
                contents,
                config,
            };
            const loggedRequestId = (0, llm_logger_js_1.log_llm_request)(agent.agent_id, 'google', model, requestParams, new Date(), requestId, agent.tags);
            requestId = loggedRequestId;
            const { waitWhilePaused } = await Promise.resolve().then(() => __importStar(require("../utils/pause_controller.cjs")));
            await waitWhilePaused(100, agent.abortSignal);
            const getStreamFn = () => this.client.models.generateContentStream(requestParams);
            const response = this.retryStreamOnIncompleteJson(getStreamFn);
            let usageMetadata;
            for await (const chunk of response) {
                chunks.push(chunk);
                if (chunk.responseId) {
                    messageId = chunk.responseId;
                }
                if ((0, pause_controller_js_1.isPaused)()) {
                    console.log(`[Gemini] System paused during stream for model ${model}. Waiting...`);
                    await waitWhilePaused(100, agent.abortSignal);
                    console.log(`[Gemini] System resumed, continuing stream for model ${model}`);
                }
                if (chunk.functionCalls && chunk.functionCalls.length > 0) {
                    for (const fc of chunk.functionCalls) {
                        if (fc && fc.name) {
                            yield withRequestId({
                                type: 'tool_start',
                                tool_call: {
                                    id: fc.id || `call_${(0, uuid_1.v4)()}`,
                                    type: 'function',
                                    function: {
                                        name: fc.name,
                                        arguments: JSON.stringify(fc.args || {}),
                                    },
                                },
                            });
                        }
                    }
                }
                for (const candidate of chunk.candidates) {
                    if (candidate.content?.parts) {
                        for (const part of candidate.content.parts) {
                            let text = '';
                            if (part.text) {
                                text += part.text;
                            }
                            if (part.executableCode) {
                                if (text) {
                                    text += '\n\n';
                                }
                                text += part.executableCode;
                            }
                            if (part.videoMetadata) {
                                if (text) {
                                    text += '\n\n';
                                }
                                text += JSON.stringify(part.videoMetadata);
                            }
                            if (text.length > 0) {
                                const ev = {
                                    type: 'message_delta',
                                    content: '',
                                    message_id: messageId,
                                    order: eventOrder++,
                                };
                                if (part.thought) {
                                    thoughtBuffer += text;
                                    ev.thinking_content = text;
                                }
                                else {
                                    contentBuffer += text;
                                    ev.content = text;
                                }
                                yield ev;
                            }
                            if (part.inlineData?.data) {
                                yield withRequestId({
                                    type: 'file_complete',
                                    data_format: 'base64',
                                    data: part.inlineData.data,
                                    mime_type: part.inlineData.mimeType || 'image/png',
                                    message_id: (0, uuid_1.v4)(),
                                    order: eventOrder++,
                                });
                            }
                        }
                    }
                    const gChunks = candidate.groundingMetadata?.groundingChunks;
                    if (Array.isArray(gChunks)) {
                        const newChunks = gChunks.filter(c => c?.web?.uri && !shownGrounding.has(c.web.uri));
                        if (newChunks.length) {
                            newChunks.forEach(c => shownGrounding.add(c.web.uri));
                            const formatted = formatGroundingChunks(newChunks);
                            yield withRequestId({
                                type: 'message_delta',
                                content: '\n\nSearch Results:\n' + formatted + '\n',
                                message_id: messageId,
                                order: eventOrder++,
                            });
                            contentBuffer += '\n\nSearch Results:\n' + formatted + '\n';
                        }
                    }
                }
                if (chunk.usageMetadata) {
                    usageMetadata = chunk.usageMetadata;
                }
            }
            if (usageMetadata) {
                const calculatedUsage = cost_tracker_js_1.costTracker.addUsage({
                    model,
                    input_tokens: usageMetadata.promptTokenCount || 0,
                    output_tokens: usageMetadata.candidatesTokenCount || 0,
                    cached_tokens: usageMetadata.cachedContentTokenCount || 0,
                    metadata: {
                        total_tokens: usageMetadata.totalTokenCount || 0,
                        reasoning_tokens: usageMetadata.thoughtsTokenCount || 0,
                        tool_tokens: usageMetadata.toolUsePromptTokenCount || 0,
                    },
                });
                if (!(0, event_controller_js_1.hasEventHandler)()) {
                    yield withRequestId({
                        type: 'cost_update',
                        usage: {
                            ...calculatedUsage,
                            total_tokens: usageMetadata.totalTokenCount || 0,
                        },
                    });
                }
            }
            else {
                console.warn('[Gemini] No usage metadata found in the response. Using token estimation.');
                let inputText = '';
                for (const content of contents) {
                    if (content.parts) {
                        for (const part of content.parts) {
                            if (part.text) {
                                inputText += part.text + '\n';
                            }
                        }
                    }
                }
                const calculatedUsage = cost_tracker_js_1.costTracker.addEstimatedUsage(model, inputText, contentBuffer + thoughtBuffer, {
                    provider: 'gemini',
                });
                if (!(0, event_controller_js_1.hasEventHandler)()) {
                    yield withRequestId({
                        type: 'cost_update',
                        usage: {
                            ...calculatedUsage,
                            total_tokens: calculatedUsage.input_tokens + calculatedUsage.output_tokens,
                        },
                    });
                }
            }
            if (contentBuffer || thoughtBuffer) {
                yield withRequestId({
                    type: 'message_complete',
                    content: contentBuffer,
                    thinking_content: thoughtBuffer,
                    message_id: messageId,
                });
            }
        }
        catch (error) {
            (0, llm_logger_js_1.log_llm_error)(requestId, error);
            const errorMessage = error instanceof Error ? error.stack || error.message : String(error);
            if (errorMessage.includes('Incomplete JSON segment')) {
                console.error('[Gemini] Stream terminated with incomplete JSON. This may indicate network issues or timeouts.');
            }
            console.error('\n=== Gemini error ===');
            console.dir(error, { depth: null });
            console.error('\n=== JSON dump of error ===');
            console.error((0, truncate_utils_js_1.truncateLargeValues)(JSON.stringify(error, Object.getOwnPropertyNames(error), 2)));
            console.error('\n=== Manual property walk ===');
            for (const key of Reflect.ownKeys(error)) {
                console.error(`${String(key)}:`, (0, truncate_utils_js_1.truncateLargeValues)(error[key]));
            }
            yield withRequestId({
                type: 'error',
                error: `Gemini error ${model}: ${errorMessage}`,
            });
            if (contentBuffer || thoughtBuffer) {
                yield withRequestId({
                    type: 'message_complete',
                    content: contentBuffer,
                    thinking_content: thoughtBuffer,
                    message_id: messageId,
                });
            }
        }
        finally {
            (0, llm_logger_js_1.log_llm_response)(requestId, chunks);
        }
    }
    async createImage(prompt, model, agent, opts) {
        const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
        let finalRequestId = requestId;
        try {
            model = model || 'gemini-2.5-flash-image-preview';
            const numberOfImages = opts?.n || 1;
            const { getToolsFromAgent } = await Promise.resolve().then(() => __importStar(require("../utils/agent.cjs")));
            const tools = agent ? await getToolsFromAgent(agent) : [];
            const hasGoogleWebSearch = tools?.some(tool => tool.definition.function.name === 'google_web_search');
            const hasOtherTools = tools?.some(tool => tool.definition.function.name !== 'google_web_search');
            if (hasOtherTools) {
                console.warn('[Gemini] Image generation ignores function tools; only google_web_search is supported.');
            }
            let aspectRatio = '1:1';
            if (opts?.size === 'landscape')
                aspectRatio = '16:9';
            else if (opts?.size === 'portrait')
                aspectRatio = '9:16';
            console.log(`[Gemini] Generating ${numberOfImages} image(s) with model ${model}, prompt: "${prompt.substring(0, 100)}${prompt.length > 100 ? '...' : ''}"`);
            if (model.includes('gemini-2.5-flash-image-preview') || model.includes('gemini-3-pro-image-preview')) {
                const constraints = [];
                const sizeMap = {
                    square: { ar: '1:1', px: '1024x1024' },
                    landscape: { ar: '16:9' },
                    portrait: { ar: '9:16' },
                    '256x256': { ar: '1:1', px: '256x256' },
                    '512x512': { ar: '1:1', px: '512x512' },
                    '1024x1024': { ar: '1:1', px: '1024x1024' },
                    '1536x1024': { ar: '3:2', px: '1536x1024' },
                    '1024x1536': { ar: '2:3', px: '1024x1536' },
                    '1696x2528': { ar: '2:3', px: '1696x2528' },
                    '2048x2048': { ar: '1:1', px: '2048x2048' },
                    '1792x1024': { ar: '16:9', px: '1792x1024' },
                    '1024x1792': { ar: '9:16', px: '1024x1792' },
                };
                const sm = opts?.size ? sizeMap[String(opts.size)] : undefined;
                if (sm?.ar)
                    constraints.push(`Aspect ratio: ${sm.ar}.`);
                if (sm?.px)
                    constraints.push(`Target size: ${sm.px} pixels (approximate).`);
                if (opts?.style)
                    constraints.push(`Style: ${opts.style}.`);
                if (opts?.background)
                    constraints.push(`Background: ${opts.background} (use transparency if supported).`);
                const imageConfig = {};
                if (sm?.ar)
                    imageConfig.aspectRatio = sm.ar;
                const qualityKey = typeof opts?.quality === 'string' ? opts.quality.toLowerCase() : '';
                const imageSizeMap = {
                    low: '1K',
                    standard: '2K',
                    medium: '2K',
                    hd: '4K',
                    high: '4K',
                };
                const imageSize = imageSizeMap[qualityKey];
                if (imageSize)
                    imageConfig.imageSize = imageSize;
                const perImageCost = this.getImageCost(model, imageSize);
                const constraintText = constraints.length
                    ? `\n\nImage constraints (please prioritize):\n- ${constraints.join('\n- ')}`
                    : '';
                const makeOne = async () => {
                    const requestParams = {
                        model,
                        contents: [
                            {
                                role: 'user',
                                parts: [
                                    ...(Array.isArray(opts?.source_images)
                                        ? opts.source_images
                                            .map((img) => typeof img === 'string' ? { _src: img } : img)
                                            .map((it) => {
                                            const src = it?.data || it?._src || it;
                                            if (typeof src !== 'string')
                                                return null;
                                            if (src.startsWith('data:')) {
                                                const m = /^data:([^;]+);base64,(.+)$/i.exec(src);
                                                if (!m)
                                                    return null;
                                                return {
                                                    inlineData: {
                                                        mimeType: m[1] || 'image/png',
                                                        data: m[2],
                                                    },
                                                };
                                            }
                                            return {
                                                fileData: {
                                                    mimeType: inferImageMimeTypeFromUrl(src),
                                                    fileUri: src,
                                                },
                                            };
                                        })
                                            .filter(Boolean)
                                        : typeof opts?.source_images === 'string'
                                            ? [
                                                (() => {
                                                    const s = String(opts?.source_images);
                                                    if (s.startsWith('data:')) {
                                                        const m = /^data:([^;]+);base64,(.+)$/i.exec(s);
                                                        return m
                                                            ? { inlineData: { mimeType: m[1] || 'image/png', data: m[2] } }
                                                            : null;
                                                    }
                                                    return {
                                                        fileData: {
                                                            mimeType: inferImageMimeTypeFromUrl(s),
                                                            fileUri: s,
                                                        },
                                                    };
                                                })(),
                                            ].filter(Boolean)
                                            : []),
                                    { text: `${prompt}${constraintText}` },
                                ],
                            },
                        ],
                        config: {
                            responseModalities: [genai_1.Modality.IMAGE, genai_1.Modality.TEXT],
                            ...(Object.keys(imageConfig).length ? { imageConfig } : {}),
                            ...(hasGoogleWebSearch ? { tools: [{ googleSearch: {} }] } : {}),
                        },
                    };
                    const loggedRequestId = (0, llm_logger_js_1.log_llm_request)(agent.agent_id || 'default', 'gemini', model, requestParams, new Date(), requestId, agent.tags);
                    finalRequestId = loggedRequestId;
                    const response = await this.client.models.generateContentStream(requestParams);
                    const images = [];
                    let usageMetadata;
                    for await (const chunk of response) {
                        if (chunk.usageMetadata) {
                            usageMetadata = chunk.usageMetadata;
                        }
                        if (!chunk.candidates)
                            continue;
                        for (const cand of chunk.candidates) {
                            const parts = cand.content?.parts || [];
                            for (const part of parts) {
                                if (part.inlineData?.data) {
                                    const mime = part.inlineData.mimeType || 'image/png';
                                    images.push(`data:${mime};base64,${part.inlineData.data}`);
                                }
                            }
                        }
                    }
                    if (images.length > 0) {
                        const baseMetadata = {
                            cost_per_image: perImageCost,
                            ...(imageSize ? { image_size: imageSize } : {}),
                        };
                        if (usageMetadata) {
                            const promptTokensRaw = usageMetadata.promptTokenCount || 0;
                            const toolTokens = usageMetadata.toolUsePromptTokenCount || 0;
                            const thoughtTokens = usageMetadata.thoughtsTokenCount || 0;
                            const candidateTokens = usageMetadata.candidatesTokenCount || 0;
                            const totalTokens = usageMetadata.totalTokenCount || 0;
                            let promptTokens = promptTokensRaw;
                            if (promptTokens === 0 && totalTokens > 0) {
                                const derivedPrompt = totalTokens - candidateTokens - toolTokens - thoughtTokens;
                                if (derivedPrompt > 0) {
                                    promptTokens = derivedPrompt;
                                }
                            }
                            const inputTokens = promptTokens + toolTokens;
                            const outputTokens = candidateTokens + thoughtTokens;
                            cost_tracker_js_1.costTracker.addUsage({
                                model,
                                image_count: images.length,
                                input_tokens: inputTokens,
                                output_tokens: outputTokens,
                                cached_tokens: usageMetadata.cachedContentTokenCount || 0,
                                request_id: opts?.request_id,
                                metadata: {
                                    ...baseMetadata,
                                    total_tokens: totalTokens,
                                    reasoning_tokens: thoughtTokens,
                                    tool_tokens: toolTokens,
                                },
                            });
                        }
                        else {
                            cost_tracker_js_1.costTracker.addUsage({
                                model,
                                image_count: images.length,
                                request_id: opts?.request_id,
                                metadata: baseMetadata,
                            });
                        }
                    }
                    return images;
                };
                const allImages = [];
                const calls = Math.max(1, numberOfImages);
                for (let i = 0; i < calls; i++) {
                    const imgs = await makeOne();
                    for (const img of imgs) {
                        if (allImages.length < numberOfImages)
                            allImages.push(img);
                    }
                    if (allImages.length >= numberOfImages)
                        break;
                }
                if (allImages.length === 0) {
                    throw new Error('No images returned from Gemini 2.5 Flash Image model');
                }
                (0, llm_logger_js_1.log_llm_response)(finalRequestId, {
                    model,
                    image_count: allImages.length,
                    cost: allImages.length * perImageCost,
                });
                return allImages;
            }
            const requestParams = {
                model,
                prompt,
                config: {
                    numberOfImages,
                    aspectRatio,
                    includeSafetyAttributes: false,
                },
            };
            const loggedRequestId = (0, llm_logger_js_1.log_llm_request)(agent.agent_id || 'default', 'gemini', model, requestParams, new Date(), requestId, agent.tags);
            finalRequestId = loggedRequestId;
            const response = await this.client.models.generateImages(requestParams);
            const images = [];
            if (response.generatedImages && response.generatedImages.length > 0) {
                for (const generatedImage of response.generatedImages) {
                    if (generatedImage.image?.imageBytes) {
                        const base64Image = `data:image/png;base64,${generatedImage.image.imageBytes}`;
                        images.push(base64Image);
                    }
                }
                const perImageCost = this.getImageCost(model);
                cost_tracker_js_1.costTracker.addUsage({
                    model,
                    image_count: images.length,
                    cost: images.length * perImageCost,
                    request_id: opts?.request_id,
                    metadata: {
                        aspect_ratio: aspectRatio,
                        cost_per_image: perImageCost,
                    },
                });
            }
            if (images.length === 0) {
                throw new Error('No images returned from Gemini/Imagen');
            }
            const perImageCost = this.getImageCost(model);
            (0, llm_logger_js_1.log_llm_response)(finalRequestId, {
                model,
                image_count: images.length,
                aspect_ratio: aspectRatio,
                cost: images.length * perImageCost,
            });
            return images;
        }
        catch (error) {
            (0, llm_logger_js_1.log_llm_error)(finalRequestId, error);
            console.error('[Gemini] Error generating image:', (0, truncate_utils_js_1.truncateLargeValues)(error));
            throw error;
        }
    }
    getImageCost(model, imageSize) {
        if (model.includes('gemini-2.5-flash-image-preview')) {
            return 0.039;
        }
        else if (model.includes('gemini-3-pro-image-preview')) {
            if (imageSize === '4K')
                return 0.24;
            return 0.134;
        }
        if (model.includes('imagen-3')) {
            return 0.04;
        }
        else if (model.includes('imagen-2')) {
            return 0.02;
        }
        return 0.04;
    }
    async createVoice(text, model, agent, opts) {
        const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
        let finalRequestId = requestId;
        try {
            console.log(`[Gemini] Generating speech with model ${model}, text: "${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"`);
            const voiceName = this.mapVoiceToGemini(opts?.voice);
            const speechConfig = {
                voiceConfig: {
                    prebuiltVoiceConfig: {
                        voiceName: voiceName,
                    },
                },
            };
            const config = {
                responseModalities: [genai_1.Modality.AUDIO],
                speechConfig: speechConfig,
            };
            let say_prefix = '';
            let say_postfix = '';
            if (opts?.speed && opts.speed !== 1.0) {
                const speedDescription = opts.speed < 1.0
                    ? `slowly at ${Math.round(opts.speed * 100)}% speed`
                    : `quickly at ${Math.round(opts.speed * 100)}% speed`;
                say_postfix = speedDescription;
            }
            if (opts?.affect) {
                say_prefix = `Sound ${opts.affect}`;
            }
            if (say_postfix || say_prefix) {
                if (say_postfix && say_prefix) {
                    text = `${say_prefix} and say ${say_postfix}:\n${text}`;
                }
                else if (say_postfix) {
                    text = `Say ${say_postfix}:\n${text}`;
                }
                else if (say_prefix) {
                    text = `${say_prefix} and say:\n${text}`;
                }
            }
            const requestParams = {
                model,
                text_length: text.length,
                voice: voiceName,
                speed: opts?.speed,
                affect: opts?.affect,
                config,
            };
            const loggedRequestId = (0, llm_logger_js_1.log_llm_request)(agent.agent_id || 'default', 'gemini', model, requestParams, new Date(), requestId, agent.tags);
            finalRequestId = loggedRequestId;
            console.log(`[Gemini] Starting generateContentStream call...`);
            const streamPromise = this.client.models.generateContentStream({
                model,
                contents: [{ role: 'user', parts: [{ text }] }],
                config,
            });
            const textLength = text.length;
            cost_tracker_js_1.costTracker.addUsage({
                model,
                input_tokens: Math.ceil(textLength / 4),
                output_tokens: 0,
                metadata: {
                    voice: voiceName,
                    text_length: textLength,
                    type: 'voice_generation',
                },
            });
            if (opts?.stream) {
                const stream = await streamPromise;
                const chunks = [];
                for await (const chunk of stream) {
                    if (chunk.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data) {
                        const part = chunk.candidates[0].content.parts[0];
                        const binaryString = atob(part.inlineData.data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        chunks.push(bytes);
                        if (part.inlineData.mimeType) {
                            console.log(`[Gemini] Audio format: ${part.inlineData.mimeType}`);
                        }
                    }
                }
                const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combined = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }
                (0, llm_logger_js_1.log_llm_response)(finalRequestId, {
                    model,
                    text_length: textLength,
                    voice: voiceName,
                    audio_size: combined.length,
                    stream: true,
                });
                return new ReadableStream({
                    start(controller) {
                        controller.enqueue(combined);
                        controller.close();
                    },
                });
            }
            let allData = new Uint8Array(0);
            const stream = await streamPromise;
            for await (const chunk of stream) {
                if (!chunk.candidates || !chunk.candidates[0]?.content?.parts) {
                    continue;
                }
                const part = chunk.candidates[0].content.parts[0];
                if (part?.inlineData?.data) {
                    const binaryString = atob(part.inlineData.data);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const newData = new Uint8Array(allData.length + bytes.length);
                    newData.set(allData);
                    newData.set(bytes, allData.length);
                    allData = newData;
                }
            }
            if (allData.length === 0) {
                throw new Error('No audio data generated from Gemini TTS');
            }
            (0, llm_logger_js_1.log_llm_response)(finalRequestId, {
                model,
                text_length: textLength,
                voice: voiceName,
                audio_size: allData.length,
                stream: false,
            });
            return allData.buffer;
        }
        catch (error) {
            (0, llm_logger_js_1.log_llm_error)(finalRequestId, error);
            console.error('[Gemini] Error generating voice:', (0, truncate_utils_js_1.truncateLargeValues)(error));
            throw error;
        }
    }
    mapVoiceToGemini(voice) {
        const geminiVoices = [
            'Kore',
            'Puck',
            'Charon',
            'Fenrir',
            'Aoede',
            'Glados',
        ];
        if (!voice) {
            return 'Kore';
        }
        if (geminiVoices.includes(voice)) {
            return voice;
        }
        const voiceMap = {
            alloy: 'Kore',
            echo: 'Puck',
            fable: 'Charon',
            onyx: 'Fenrir',
            nova: 'Aoede',
            shimmer: 'Glados',
            male: 'Puck',
            female: 'Kore',
            neutral: 'Charon',
            young: 'Aoede',
            mature: 'Fenrir',
            robotic: 'Glados',
            kore: 'Kore',
            puck: 'Puck',
            charon: 'Charon',
            fenrir: 'Fenrir',
            aoede: 'Aoede',
            glados: 'Glados',
        };
        const mappedVoice = voiceMap[voice.toLowerCase()];
        if (mappedVoice) {
            return mappedVoice;
        }
        console.warn(`[Gemini] Unknown voice '${voice}', using default voice 'Kore'`);
        return 'Kore';
    }
    async *createTranscription(audio, agent, model, opts) {
        const requestId = `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
        let finalRequestId = requestId;
        let session = null;
        let isConnected = false;
        try {
            const ai = new genai_1.GoogleGenAI({
                apiKey: this.apiKey,
                httpOptions: { apiVersion: 'v1beta' },
            });
            const realtimeInputConfig = opts?.realtimeInputConfig || {
                automaticActivityDetection: {
                    disabled: false,
                    startOfSpeechSensitivity: 'START_SENSITIVITY_HIGH',
                    endOfSpeechSensitivity: 'END_SENSITIVITY_LOW',
                },
            };
            const speechConfig = opts?.speechConfig || {
                languageCode: 'en-US',
            };
            const systemInstruction = agent.instructions || `You should reply only "OK" to every single message from the user. Nothing else.`;
            console.log('[Gemini] Connecting to Live API for transcription...');
            const connectionPromise = new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Connection timeout'));
                }, 10000);
                const config = {
                    responseModalities: [genai_1.Modality.TEXT],
                    mediaResolution: genai_1.MediaResolution.MEDIA_RESOLUTION_MEDIUM,
                    speechConfig,
                    realtimeInputConfig,
                    systemInstruction: {
                        parts: [{ text: systemInstruction }],
                    },
                    inputAudioTranscription: {},
                };
                ai.live
                    .connect({
                    model: model,
                    config,
                    callbacks: {
                        onopen: () => {
                            clearTimeout(timeout);
                            console.log('[Gemini] Live session connected');
                            isConnected = true;
                            resolve();
                        },
                        onmessage: async (msg) => {
                            if (msg.serverContent?.inputTranscription?.text) {
                                const previewEvent = {
                                    type: 'transcription_turn_delta',
                                    timestamp: new Date().toISOString(),
                                    delta: msg.serverContent.inputTranscription.text,
                                };
                                transcriptEvents.push(previewEvent);
                            }
                            if (msg.serverContent?.turnComplete) {
                                const turnEvent = {
                                    type: 'transcription_turn_complete',
                                    timestamp: new Date().toISOString(),
                                };
                                transcriptEvents.push(turnEvent);
                            }
                            if (msg.usageMetadata) {
                                if (msg.usageMetadata.promptTokensDetails &&
                                    Array.isArray(msg.usageMetadata.promptTokensDetails)) {
                                    for (const detail of msg.usageMetadata.promptTokensDetails) {
                                        if (detail.modality && detail.tokenCount > 0) {
                                            cost_tracker_js_1.costTracker.addUsage({
                                                model: model,
                                                input_tokens: detail.tokenCount,
                                                output_tokens: 0,
                                                input_modality: detail.modality.toLowerCase(),
                                                metadata: {
                                                    totalTokens: msg.usageMetadata.totalTokenCount || 0,
                                                    source: 'gemini-live-transcription',
                                                    modalityType: 'input',
                                                    originalModality: detail.modality,
                                                },
                                            });
                                        }
                                    }
                                }
                                if (msg.usageMetadata.responseTokensDetails &&
                                    Array.isArray(msg.usageMetadata.responseTokensDetails)) {
                                    for (const detail of msg.usageMetadata.responseTokensDetails) {
                                        if (detail.modality && detail.tokenCount > 0) {
                                            cost_tracker_js_1.costTracker.addUsage({
                                                model: model,
                                                input_tokens: 0,
                                                output_tokens: detail.tokenCount,
                                                output_modality: detail.modality.toLowerCase(),
                                                metadata: {
                                                    totalTokens: msg.usageMetadata.totalTokenCount || 0,
                                                    source: 'gemini-live-transcription',
                                                    modalityType: 'output',
                                                    originalModality: detail.modality,
                                                },
                                            });
                                        }
                                    }
                                }
                                if ((!msg.usageMetadata.promptTokensDetails ||
                                    msg.usageMetadata.promptTokensDetails.length === 0) &&
                                    (!msg.usageMetadata.responseTokensDetails ||
                                        msg.usageMetadata.responseTokensDetails.length === 0)) {
                                    cost_tracker_js_1.costTracker.addUsage({
                                        model: model,
                                        input_tokens: msg.usageMetadata.promptTokenCount || 0,
                                        output_tokens: msg.usageMetadata.responseTokenCount || 0,
                                        input_modality: 'audio',
                                        output_modality: 'text',
                                        metadata: {
                                            totalTokens: msg.usageMetadata.totalTokenCount || 0,
                                            source: 'gemini-live-transcription',
                                        },
                                    });
                                }
                            }
                        },
                        onerror: (err) => {
                            console.error('[Gemini] Live API error:', (0, truncate_utils_js_1.truncateLargeValues)({
                                code: err.code,
                                reason: err.reason,
                                wasClean: err.wasClean,
                            }));
                            connectionError = err;
                        },
                        onclose: (event) => {
                            console.log('[Gemini] Live session closed');
                            if (event) {
                                console.log('[Gemini] Close event details:', {
                                    code: event.code,
                                    reason: event.reason,
                                    wasClean: event.wasClean,
                                });
                            }
                            isConnected = false;
                        },
                    },
                })
                    .then(async (s) => {
                    session = s;
                });
            });
            const transcriptEvents = [];
            let connectionError = null;
            await connectionPromise;
            const requestParams = {
                model,
                systemInstruction,
                realtimeInputConfig,
                speechConfig,
                mediaResolution: genai_1.MediaResolution.MEDIA_RESOLUTION_MEDIUM,
            };
            const loggedRequestId = (0, llm_logger_js_1.log_llm_request)(agent.agent_id, 'gemini', model, requestParams, new Date(), requestId, agent.tags);
            finalRequestId = loggedRequestId;
            const audioStream = normalizeAudioSource(audio);
            const reader = audioStream.getReader();
            const sendAudioChunk = async (chunk) => {
                try {
                    const base64Data = chunk.toString('base64');
                    await session.sendRealtimeInput({
                        media: {
                            mimeType: 'audio/pcm;rate=16000',
                            data: base64Data,
                        },
                    });
                }
                catch (err) {
                    console.error('[Gemini] Error sending audio chunk:', (0, truncate_utils_js_1.truncateLargeValues)(err));
                    connectionError = err;
                    throw err;
                }
            };
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done)
                        break;
                    if (value && session && isConnected) {
                        const chunk = value instanceof Buffer ? value : Buffer.from(value);
                        await sendAudioChunk(chunk);
                    }
                    if (transcriptEvents.length > 0) {
                        const events = transcriptEvents.splice(0, transcriptEvents.length);
                        for (const event of events) {
                            yield event;
                        }
                    }
                    if (connectionError) {
                        throw connectionError;
                    }
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
                if (transcriptEvents.length > 0) {
                    const events = transcriptEvents.splice(0, transcriptEvents.length);
                    for (const event of events) {
                        yield event;
                    }
                }
                (0, llm_logger_js_1.log_llm_response)(finalRequestId, {
                    model,
                    transcription_complete: true,
                });
            }
            finally {
                reader.releaseLock();
                if (session) {
                    session.close();
                }
            }
        }
        catch (error) {
            (0, llm_logger_js_1.log_llm_error)(finalRequestId, error);
            console.error('[Gemini] Transcription error:', (0, truncate_utils_js_1.truncateLargeValues)(error));
            const errorEvent = {
                type: 'error',
                timestamp: new Date().toISOString(),
                error: error instanceof Error ? error.message : 'Transcription failed',
            };
            yield errorEvent;
        }
    }
    async createLiveSession(config, agent, model, opts) {
        console.log(`[Gemini] Creating Live session with model ${model}`);
        const liveModels = [
            'gemini-2.0-flash-live-001',
            'gemini-live-2.5-flash-preview',
            'gemini-2.5-flash-preview-native-audio-dialog',
            'gemini-2.5-flash-exp-native-audio-thinking-dialog',
            'gemini-2.0-flash-exp',
        ];
        if (!liveModels.some(m => model.includes(m))) {
            throw new Error(`Model ${model} does not support Live API. Supported models: ${liveModels.join(', ')}`);
        }
        const sessionId = (0, uuid_1.v4)();
        const liveSession = new GeminiLiveSession(sessionId, this.client, model, config, agent, opts);
        await liveSession.initialize();
        return liveSession;
    }
}
exports.GeminiProvider = GeminiProvider;
function normalizeAudioSource(source) {
    if (source instanceof ReadableStream) {
        return source;
    }
    if (typeof source === 'object' && source !== null && Symbol.asyncIterator in source) {
        return new ReadableStream({
            async start(controller) {
                try {
                    for await (const chunk of source) {
                        controller.enqueue(chunk);
                    }
                    controller.close();
                }
                catch (error) {
                    controller.error(error);
                }
            },
        });
    }
    if (typeof source === 'function') {
        const iterable = source();
        return normalizeAudioSource(iterable);
    }
    if (source instanceof ArrayBuffer || source instanceof Uint8Array) {
        const data = source instanceof ArrayBuffer ? new Uint8Array(source) : source;
        return new ReadableStream({
            start(controller) {
                controller.enqueue(data);
                controller.close();
            },
        });
    }
    throw new Error(`Unsupported audio source type: ${typeof source}`);
}
class GeminiLiveSession {
    sessionId;
    ai;
    model;
    config;
    agent;
    options;
    session = null;
    eventQueue = [];
    eventResolvers = [];
    _isActive = true;
    sessionClosed = false;
    messageHistory = [];
    currentTurn = null;
    constructor(sessionId, ai, model, config, agent, options) {
        this.sessionId = sessionId;
        this.ai = ai;
        this.model = model;
        this.config = config;
        this.agent = agent;
        this.options = options;
    }
    async initialize() {
        const connectionPromise = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Connection timeout'));
            }, 30000);
            const tools = [];
            if (this.config.tools) {
                for (const toolGroup of this.config.tools) {
                    if (toolGroup.functionDeclarations) {
                        const functionDeclarations = toolGroup.functionDeclarations.map(func => ({
                            name: func.name,
                            description: func.description,
                            parameters: convertParameterToGeminiFormat(func.parameters),
                        }));
                        tools.push({ functionDeclarations });
                    }
                    if (toolGroup.codeExecution) {
                        tools.push({ codeExecution: {} });
                    }
                    if (toolGroup.googleSearch) {
                        tools.push({ googleSearch: {} });
                    }
                }
            }
            let systemInstruction = undefined;
            if (this.agent.instructions) {
                systemInstruction = {
                    parts: [{ text: this.agent.instructions }],
                };
            }
            const responseModalities = this.config.responseModalities[0] === 'AUDIO' ? [genai_1.Modality.AUDIO] : [genai_1.Modality.TEXT];
            const config = {
                responseModalities,
                systemInstruction,
                tools: tools.length > 0 ? tools : undefined,
            };
            if (this.config.responseModalities[0] === 'AUDIO' && this.config.speechConfig) {
                config.speechConfig = {
                    voiceConfig: this.config.speechConfig.voiceConfig,
                };
            }
            if (this.config.realtimeInputConfig) {
                config.realtimeInputConfig = {
                    automaticActivityDetection: this.config.realtimeInputConfig.automaticActivityDetection
                        ? {
                            disabled: this.config.realtimeInputConfig.automaticActivityDetection.disabled,
                        }
                        : undefined,
                };
            }
            if (this.config.inputAudioTranscription) {
                config.inputAudioTranscription = true;
            }
            if (this.config.outputAudioTranscription) {
                config.outputAudioTranscription = true;
            }
            if (this.config.enableAffectiveDialog) {
                config.enableAffectiveDialog = true;
            }
            if (this.config.proactivity) {
                config.proactivity = this.config.proactivity;
            }
            console.log('[Gemini] Connecting with config:', JSON.stringify(config, null, 2));
            this.ai.live
                .connect({
                model: this.model,
                config,
                callbacks: {
                    onopen: () => {
                        clearTimeout(timeout);
                        console.log('[Gemini] Live session connected');
                        this.pushEvent({
                            type: 'live_ready',
                            timestamp: new Date().toISOString(),
                        });
                        resolve();
                    },
                    onmessage: (msg) => {
                        this.handleMessage(msg);
                    },
                    onerror: (err) => {
                        console.error('[Gemini] Live API error:', (0, truncate_utils_js_1.truncateLargeValues)(err));
                        console.error('[Gemini] Error details:', (0, truncate_utils_js_1.truncateLargeValues)(JSON.stringify(err, null, 2)));
                        this.pushEvent({
                            type: 'error',
                            timestamp: new Date().toISOString(),
                            error: err.message || String(err),
                            code: err.code,
                            recoverable: true,
                        });
                    },
                    onclose: (event) => {
                        console.log('[Gemini] Live session closed', event);
                        if (event) {
                            console.log('[Gemini] Close event details:', {
                                code: event.code,
                                reason: event.reason,
                                wasClean: event.wasClean,
                            });
                        }
                        this._isActive = false;
                        this.sessionClosed = true;
                        this.resolveAllWaitingEvents();
                    },
                },
            })
                .then(s => {
                this.session = s;
            });
        });
        await connectionPromise;
    }
    handleMessage(msg) {
        console.log('[Gemini] Received message:', JSON.stringify(msg, null, 2));
        if (msg.error) {
            console.error('[Gemini] Error in message:', (0, truncate_utils_js_1.truncateLargeValues)(msg.error));
            this.pushEvent({
                type: 'error',
                timestamp: new Date().toISOString(),
                error: msg.error.message || JSON.stringify(msg.error),
                code: msg.error.code || 'UNKNOWN_ERROR',
                recoverable: false,
            });
            return;
        }
        if (msg.serverContent?.modelTurn?.parts) {
            for (const part of msg.serverContent.modelTurn.parts) {
                if (part.inlineData?.mimeType?.startsWith('audio/')) {
                    this.pushEvent({
                        type: 'audio_output',
                        timestamp: new Date().toISOString(),
                        data: part.inlineData.data,
                        format: {
                            sampleRate: 24000,
                            channels: 1,
                            encoding: 'pcm',
                        },
                    });
                }
                if (part.text) {
                    if (!this.currentTurn || this.currentTurn.role !== 'model') {
                        this.currentTurn = { role: 'model', text: '' };
                        this.pushEvent({
                            type: 'turn_start',
                            timestamp: new Date().toISOString(),
                            role: 'model',
                        });
                    }
                    this.currentTurn.text += part.text;
                    this.pushEvent({
                        type: 'text_delta',
                        timestamp: new Date().toISOString(),
                        delta: part.text,
                    });
                    this.pushEvent({
                        type: 'message_delta',
                        timestamp: new Date().toISOString(),
                        delta: part.text,
                    });
                }
            }
        }
        if (msg.serverContent?.modelTurn?.parts) {
            for (const part of msg.serverContent.modelTurn.parts) {
                if (part.functionCall) {
                    const toolCall = {
                        id: (0, uuid_1.v4)(),
                        type: 'function',
                        function: {
                            name: part.functionCall.name,
                            arguments: JSON.stringify(part.functionCall.args),
                        },
                    };
                    this.pushEvent({
                        type: 'tool_call',
                        timestamp: new Date().toISOString(),
                        toolCalls: [toolCall],
                    });
                }
            }
        }
        if (msg.serverContent?.inputAudioTranscription) {
            const text = msg.serverContent.inputAudioTranscription.text ||
                msg.serverContent.inputAudioTranscription.transcript ||
                '';
            if (text) {
                this.pushEvent({
                    type: 'transcription_input',
                    timestamp: new Date().toISOString(),
                    text,
                });
            }
        }
        if (msg.serverContent?.outputTranscription) {
            const text = msg.serverContent.outputTranscription.text || '';
            if (text) {
                this.pushEvent({
                    type: 'transcription_output',
                    timestamp: new Date().toISOString(),
                    text,
                });
            }
        }
        if (msg.serverContent?.turnComplete) {
            if (this.currentTurn) {
                const message = this.currentTurn.role === 'model'
                    ? {
                        type: 'message',
                        role: 'assistant',
                        content: this.currentTurn.text,
                        status: 'completed',
                    }
                    : {
                        type: 'message',
                        role: 'user',
                        content: this.currentTurn.text,
                    };
                this.messageHistory.push(message);
                this.pushEvent({
                    type: 'turn_complete',
                    timestamp: new Date().toISOString(),
                    role: this.currentTurn.role,
                    message,
                });
                this.currentTurn = null;
            }
        }
        if (msg.serverContent?.interrupted) {
            const cancelledToolCalls = [];
            if (msg.serverContent.cancelledFunctionCalls) {
                cancelledToolCalls.push(...msg.serverContent.cancelledFunctionCalls.map((fc) => fc.id));
            }
            this.pushEvent({
                type: 'interrupted',
                timestamp: new Date().toISOString(),
                cancelledToolCalls,
            });
        }
        if (msg.usageMetadata) {
            const usage = msg.usageMetadata;
            const inputTokens = usage.promptTokenCount || 0;
            const outputTokens = usage.candidatesTokenCount || 0;
            const totalTokens = usage.totalTokenCount || 0;
            cost_tracker_js_1.costTracker.addUsage({
                model: this.model,
                input_tokens: inputTokens,
                output_tokens: outputTokens,
                cached_tokens: usage.cachedContentTokenCount || 0,
                metadata: {
                    total_tokens: totalTokens,
                    source: 'gemini-live',
                },
            });
        }
    }
    async sendAudio(audio) {
        if (!this.session || !this._isActive) {
            console.error(`[GeminiLiveSession ${this.sessionId}] Cannot send audio - session not active`);
            throw new Error('Session is not active');
        }
        console.log(`[GeminiLiveSession ${this.sessionId}] Sending audio: ${audio.data.length} chars (base64), mimeType: ${audio.mimeType}`);
        try {
            await this.session.sendRealtimeInput({
                media: {
                    mimeType: audio.mimeType,
                    data: audio.data,
                },
            });
            console.log(`[GeminiLiveSession ${this.sessionId}] Audio sent successfully`);
        }
        catch (error) {
            console.error(`[GeminiLiveSession ${this.sessionId}] Error sending audio:`, (0, truncate_utils_js_1.truncateLargeValues)(error));
            throw error;
        }
        const size = Math.ceil((audio.data.length * 3) / 4);
        this.pushEvent({
            type: 'audio_input',
            timestamp: new Date().toISOString(),
            size,
        });
    }
    async sendText(text, role = 'user') {
        if (!this.session || !this._isActive) {
            throw new Error('Session is not active');
        }
        const message = {
            role: role === 'assistant' ? 'model' : 'user',
            parts: [{ text }],
        };
        await this.session.sendClientContent({
            turns: [message],
        });
        this.pushEvent({
            type: 'turn_start',
            timestamp: new Date().toISOString(),
            role: role === 'assistant' ? 'model' : 'user',
        });
    }
    async sendToolResponse(toolResults) {
        if (!this.session || !this._isActive) {
            throw new Error('Session is not active');
        }
        const functionResponses = toolResults.map(result => ({
            id: result.call_id || result.id,
            name: result.toolCall.function.name,
            response: result.error ? { error: result.error } : { result: result.output },
        }));
        await this.session.sendToolResponse({ functionResponses });
    }
    async *getEventStream() {
        while (this._isActive || this.eventQueue.length > 0) {
            if (this.eventQueue.length > 0) {
                yield this.eventQueue.shift();
            }
            else {
                const result = await new Promise(resolve => {
                    if (this.sessionClosed && this.eventQueue.length === 0) {
                        resolve({ done: true, value: undefined });
                    }
                    else {
                        this.eventResolvers.push(resolve);
                    }
                });
                if (result.done)
                    break;
                if (result.value)
                    yield result.value;
            }
        }
    }
    async close() {
        if (this.session && this._isActive) {
            this._isActive = false;
            await this.session.close();
        }
    }
    isActive() {
        return this._isActive;
    }
    pushEvent(event) {
        if (this.eventResolvers.length > 0) {
            const resolver = this.eventResolvers.shift();
            resolver({ value: event, done: false });
        }
        else {
            this.eventQueue.push(event);
        }
    }
    resolveAllWaitingEvents() {
        for (const resolver of this.eventResolvers) {
            resolver({ done: true, value: undefined });
        }
        this.eventResolvers = [];
    }
}
exports.geminiProvider = new GeminiProvider();
//# sourceMappingURL=gemini.js.map