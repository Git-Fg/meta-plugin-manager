"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensembleRequest = ensembleRequest;
exports.mergeHistoryThread = mergeHistoryThread;
const crypto_1 = require("crypto");
const model_provider_js_1 = require("../model_providers/model_provider.cjs");
const message_history_js_1 = require("../utils/message_history.cjs");
const tool_execution_manager_js_1 = require("../utils/tool_execution_manager.cjs");
const tool_result_processor_js_1 = require("../utils/tool_result_processor.cjs");
const verification_js_1 = require("../utils/verification.cjs");
const image_to_text_js_1 = require("../utils/image_to_text.cjs");
const pause_controller_js_1 = require("../utils/pause_controller.cjs");
const event_controller_js_1 = require("../utils/event_controller.cjs");
const message_converter_js_1 = require("../utils/message_converter.cjs");
const truncate_utils_js_1 = require("../utils/truncate_utils.cjs");
const MAX_ERROR_ATTEMPTS = 5;
(0, verification_js_1.setEnsembleRequestFunction)(ensembleRequest);
(0, image_to_text_js_1.setEnsembleRequestFunction)(ensembleRequest);
async function* ensembleRequest(messages, agent = {}) {
    const conversationHistory = agent?.historyThread || messages;
    if (agent.instructions) {
        const alreadyHasInstructions = conversationHistory.some(msg => {
            return (msg.type === 'message' &&
                msg.role === 'system' &&
                'content' in msg &&
                typeof msg.content === 'string' &&
                msg.content.trim() === agent.instructions.trim());
        });
        if (!alreadyHasInstructions) {
            const instructionsMessage = {
                type: 'message',
                role: 'system',
                content: agent.instructions,
                id: (0, crypto_1.randomUUID)(),
            };
            conversationHistory.unshift(instructionsMessage);
            yield {
                type: 'response_output',
                message: instructionsMessage,
                request_id: (0, crypto_1.randomUUID)(),
            };
            agent.instructions = undefined;
        }
    }
    const history = new message_history_js_1.MessageHistory(conversationHistory, {
        compactToolCalls: true,
        preserveSystemMessages: true,
        compactionThreshold: 0.7,
    });
    try {
        let totalToolCalls = 0;
        let toolCallRounds = 0;
        let errorRounds = 0;
        const maxToolCalls = agent?.maxToolCalls ?? 200;
        const maxRounds = agent?.maxToolCallRoundsPerTurn ?? Infinity;
        let hasToolCalls = false;
        let hasError = false;
        let lastMessageContent = '';
        const modelHistory = [];
        do {
            hasToolCalls = false;
            hasError = false;
            const model = await (0, model_provider_js_1.getModelFromAgent)(agent, 'reasoning_mini', modelHistory);
            modelHistory.push(model);
            const stream = executeRound(model, agent, history, totalToolCalls, maxToolCalls);
            for await (const event of stream) {
                yield event;
                switch (event.type) {
                    case 'message_complete': {
                        const messageEvent = event;
                        if (messageEvent.content) {
                            lastMessageContent = messageEvent.content;
                        }
                        break;
                    }
                    case 'tool_start': {
                        const toolEvent = event;
                        if (toolEvent.tool_call) {
                            const toolName = toolEvent.tool_call.function.name;
                            if (toolName !== 'task_complete' && toolName !== 'task_fatal_error') {
                                hasToolCalls = true;
                            }
                        }
                        ++totalToolCalls;
                        break;
                    }
                    case 'error': {
                        hasError = true;
                        break;
                    }
                }
            }
            if (hasToolCalls) {
                ++toolCallRounds;
                if (agent.modelSettings?.tool_choice) {
                    delete agent.modelSettings.tool_choice;
                }
            }
            if (hasError) {
                ++errorRounds;
            }
        } while ((hasError && errorRounds < MAX_ERROR_ATTEMPTS) ||
            (hasToolCalls && toolCallRounds < maxRounds && totalToolCalls < maxToolCalls));
        if (hasToolCalls && toolCallRounds >= maxRounds) {
            console.log('[ensembleRequest] Tool call rounds limit reached');
        }
        else if (hasToolCalls && totalToolCalls >= maxToolCalls) {
            console.log('[ensembleRequest] Total tool calls limit reached');
        }
        if (agent?.verifier && lastMessageContent) {
            const verificationResult = await performVerification(agent, lastMessageContent, await history.getMessages());
            if (verificationResult) {
                for await (const event of verificationResult) {
                    yield event;
                }
            }
        }
    }
    catch (err) {
        const error = err;
        yield {
            type: 'error',
            error: error.message || 'Unknown error',
            code: error.code,
            details: error.details,
            recoverable: error.recoverable,
            timestamp: new Date().toISOString(),
        };
    }
    finally {
        yield {
            type: 'stream_end',
            timestamp: new Date().toISOString(),
        };
    }
}
async function* executeRound(model, agent, history, currentToolCalls, maxToolCalls) {
    const requestId = (0, crypto_1.randomUUID)();
    const startTime = Date.now();
    let totalCost = 0;
    let messages = await history.getMessages(model);
    const agentStartEvent = {
        type: 'agent_start',
        request_id: requestId,
        input: 'content' in messages[0] && typeof messages[0].content === 'string' ? messages[0].content : undefined,
        timestamp: new Date().toISOString(),
        agent: {
            agent_id: agent.agent_id,
            name: agent.name,
            parent_id: agent.parent_id,
            model: agent.model || model,
            modelClass: agent.modelClass,
            cwd: agent.cwd,
            modelScores: agent.modelScores,
            disabledModels: agent.disabledModels,
            tags: agent.tags,
        },
    };
    yield agentStartEvent;
    await (0, event_controller_js_1.emitEvent)(agentStartEvent, agent, model);
    if (agent.onRequest) {
        [agent, messages] = await agent.onRequest(agent, messages);
    }
    await (0, pause_controller_js_1.waitWhilePaused)(100, agent.abortSignal);
    const provider = (0, model_provider_js_1.getModelProvider)(model);
    const stream = 'createResponseStreamWithRetry' in provider
        ? provider.createResponseStreamWithRetry(messages, model, agent, requestId)
        : provider.createResponseStream(messages, model, agent, requestId);
    const toolPromises = [];
    const toolCallFormattedArgs = new Map();
    const toolEventBuffer = [];
    agent.onToolEvent = async (event) => {
        toolEventBuffer.push(event);
    };
    for await (let event of stream) {
        event = { ...event, request_id: requestId };
        if (event.type === 'tool_start') {
            const toolEvent = event;
            if (toolEvent.tool_call) {
                const toolCall = toolEvent.tool_call;
                let argumentsFormatted;
                try {
                    const tool = agent.tools?.find(t => t.definition.function.name === toolCall.function.name);
                    if (tool && 'definition' in tool && tool.definition.function.parameters.properties) {
                        const parsedArgs = JSON.parse(toolCall.function.arguments || '{}');
                        if (typeof parsedArgs === 'object' && parsedArgs !== null && !Array.isArray(parsedArgs)) {
                            const paramNames = Object.keys(tool.definition.function.parameters.properties);
                            const orderedArgs = {};
                            for (const param of paramNames) {
                                if (param in parsedArgs) {
                                    orderedArgs[param] = parsedArgs[param];
                                }
                            }
                            argumentsFormatted = JSON.stringify(orderedArgs, null, 2);
                        }
                    }
                }
                catch (error) {
                    console.debug('Failed to format tool arguments:', error);
                }
                if (argumentsFormatted) {
                    toolCallFormattedArgs.set(toolCall.id, argumentsFormatted);
                }
                const modifiedEvent = {
                    ...event,
                    tool_call: {
                        ...toolCall,
                        function: {
                            ...toolCall.function,
                            arguments_formatted: argumentsFormatted,
                        },
                    },
                };
                event = modifiedEvent;
            }
        }
        yield event;
        await (0, event_controller_js_1.emitEvent)(event, agent, model);
        switch (event.type) {
            case 'cost_update': {
                const costEvent = event;
                if (costEvent.usage?.cost) {
                    totalCost += costEvent.usage.cost;
                }
                break;
            }
            case 'message_complete': {
                const messageEvent = event;
                if (messageEvent.thinking_content ||
                    (!messageEvent.content && messageEvent.message_id)) {
                    const thinkingMessage = (0, message_converter_js_1.convertToThinkingMessage)(messageEvent, model);
                    if (agent.onThinking) {
                        await agent.onThinking(thinkingMessage);
                    }
                    history.add(thinkingMessage);
                    yield {
                        type: 'response_output',
                        message: thinkingMessage,
                        request_id: requestId,
                    };
                }
                if (messageEvent.content) {
                    const contentMessage = (0, message_converter_js_1.convertToOutputMessage)(messageEvent, model, 'completed');
                    if (agent.onResponse) {
                        await agent.onResponse(contentMessage);
                    }
                    history.add(contentMessage);
                    yield {
                        type: 'response_output',
                        message: contentMessage,
                        request_id: requestId,
                    };
                }
                break;
            }
            case 'tool_start': {
                const toolEvent = event;
                if (!toolEvent.tool_call) {
                    break;
                }
                const remainingCalls = maxToolCalls - currentToolCalls;
                if (remainingCalls <= 0) {
                    console.warn(`Tool call limit reached (${maxToolCalls}). Skipping tool calls.`);
                    break;
                }
                const toolCall = toolEvent.tool_call;
                const functionCall = (0, message_converter_js_1.convertToFunctionCall)(toolCall, model, 'completed');
                toolPromises.push(processToolCall(toolCall, agent));
                history.add(functionCall);
                yield {
                    type: 'response_output',
                    message: functionCall,
                    request_id: requestId,
                };
                break;
            }
            case 'error': {
                console.error('[executeRound] Error event:', (0, truncate_utils_js_1.truncateLargeValues)(event.error));
                break;
            }
        }
    }
    const request_duration = Date.now() - startTime;
    const toolResults = await Promise.all(toolPromises);
    for (const toolResult of toolResults) {
        const toolName = toolResult.toolCall.function.name;
        const isSpecialTool = toolName === 'task_complete' || toolName === 'task_fatal_error';
        const formattedArgs = toolCallFormattedArgs.get(toolResult.toolCall.id);
        const toolCallWithFormattedArgs = formattedArgs
            ? {
                ...toolResult.toolCall,
                function: {
                    ...toolResult.toolCall.function,
                    arguments_formatted: formattedArgs,
                },
            }
            : toolResult.toolCall;
        const toolDoneEvent = {
            type: 'tool_done',
            request_id: requestId,
            tool_call: toolCallWithFormattedArgs,
            result: {
                call_id: toolResult.call_id || toolResult.id,
                output: toolResult.output,
                error: toolResult.error,
            },
        };
        yield toolDoneEvent;
        await (0, event_controller_js_1.emitEvent)(toolDoneEvent, agent, model);
        if (!isSpecialTool) {
            const functionOutput = (0, message_converter_js_1.convertToFunctionCallOutput)(toolResult, model, 'completed');
            history.add(functionOutput);
            yield {
                type: 'response_output',
                message: functionOutput,
                request_id: requestId,
            };
        }
    }
    const duration_with_tools = Date.now() - startTime;
    const agentDoneEvent = {
        type: 'agent_done',
        request_id: requestId,
        request_cost: totalCost > 0 ? totalCost : undefined,
        request_duration,
        duration_with_tools,
        timestamp: new Date().toISOString(),
    };
    yield agentDoneEvent;
    await (0, event_controller_js_1.emitEvent)(agentDoneEvent, agent, model);
    for (const bufferedEvent of toolEventBuffer) {
        yield { ...bufferedEvent, request_id: requestId };
    }
}
async function* performVerification(agent, output, messages, attempt = 0) {
    if (!agent.verifier)
        return;
    const maxAttempts = agent.maxVerificationAttempts || 2;
    const verification = await (0, verification_js_1.verifyOutput)(agent.verifier, output, messages);
    if (verification.status === 'pass') {
        yield {
            type: 'message_delta',
            content: '\n\n✓ Output verified',
        };
        return;
    }
    if (attempt < maxAttempts - 1) {
        yield {
            type: 'message_delta',
            content: `\n\n⚠️ Verification failed: ${verification.reason}\n\nRetrying...`,
        };
        const retryMessages = [
            ...messages,
            {
                type: 'message',
                role: 'assistant',
                content: output,
                status: 'completed',
            },
            {
                type: 'message',
                role: 'developer',
                content: `Verification failed: ${verification.reason}\n\nPlease correct your response.`,
            },
        ];
        const retryAgent = {
            ...agent,
            verifier: undefined,
            historyThread: retryMessages,
        };
        const retryStream = ensembleRequest(retryMessages, retryAgent);
        let retryOutput = '';
        for await (const event of retryStream) {
            yield event;
            if (event.type === 'message_complete' && 'content' in event) {
                retryOutput = event.content;
            }
        }
        if (retryOutput) {
            yield* performVerification(agent, retryOutput, messages, attempt + 1);
        }
    }
    else {
        yield {
            type: 'message_delta',
            content: `\n\n❌ Verification failed after ${maxAttempts} attempts: ${verification.reason}`,
        };
    }
}
async function processToolCall(toolCall, agent) {
    if (agent.onToolCall) {
        await agent.onToolCall(toolCall);
    }
    try {
        if (!agent.tools) {
            throw new Error('No tools available for agent');
        }
        const tool = agent.tools.find(t => t.definition.function.name === toolCall.function.name);
        if (!tool || !('function' in tool)) {
            throw new Error(`Tool ${toolCall.function.name} not found`);
        }
        const rawResult = await (0, tool_execution_manager_js_1.handleToolCall)(toolCall, tool, agent);
        const processedResult = await (0, tool_result_processor_js_1.processToolResult)(toolCall, rawResult, agent, tool.allowSummary);
        const toolCallResult = {
            toolCall,
            id: toolCall.id,
            call_id: toolCall.call_id || toolCall.id,
            output: processedResult,
        };
        if (agent.onToolResult) {
            await agent.onToolResult(toolCallResult);
        }
        return toolCallResult;
    }
    catch (error) {
        const errorOutput = error instanceof Error
            ? `Tool execution failed: ${error.message}`
            : `Tool execution failed: ${String(error)}`;
        const toolCallResult = {
            toolCall,
            id: toolCall.id,
            call_id: toolCall.call_id || toolCall.id,
            error: errorOutput,
        };
        if (agent.onToolError) {
            await agent.onToolError(toolCallResult);
        }
        return toolCallResult;
    }
}
function mergeHistoryThread(mainHistory, thread, startIndex) {
    const newMessages = thread.slice(startIndex);
    mainHistory.push(...newMessages);
}
//# sourceMappingURL=ensemble_request.js.map