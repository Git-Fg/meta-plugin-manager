"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModelClass = getModelClass;
exports.getModelClassNames = getModelClassNames;
exports.overrideModelClass = overrideModelClass;
exports.setModelClassModels = setModelClassModels;
exports.addModelToClass = addModelToClass;
exports.removeModelFromClass = removeModelFromClass;
exports.setModelClassRandom = setModelClassRandom;
exports.resetModelClass = resetModelClass;
exports.getAllModelClasses = getAllModelClasses;
exports.updateModelClasses = updateModelClasses;
const model_data_js_1 = require("../data/model_data.cjs");
const external_models_js_1 = require("./external_models.cjs");
function getModelClass(className) {
    if (!(className in model_data_js_1.MODEL_CLASSES)) {
        return undefined;
    }
    const baseConfig = model_data_js_1.MODEL_CLASSES[className];
    const override = (0, external_models_js_1.getModelClassOverride)(className);
    if (!override) {
        return { ...baseConfig };
    }
    return {
        ...baseConfig,
        ...override,
        models: override.models || baseConfig.models,
    };
}
function getModelClassNames() {
    return Object.keys(model_data_js_1.MODEL_CLASSES);
}
function overrideModelClass(className, config) {
    if (!(className in model_data_js_1.MODEL_CLASSES)) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    if (config.models) {
        for (const modelId of config.models) {
            if (!(0, model_data_js_1.findModel)(modelId)) {
                console.warn(`Model '${modelId}' not found in registry, but adding to class '${className}' anyway`);
            }
        }
    }
    (0, external_models_js_1.overrideModelClass)(className, config);
}
function setModelClassModels(className, models, random) {
    const currentConfig = getModelClass(className);
    if (!currentConfig) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    overrideModelClass(className, {
        models,
        random: random !== undefined ? random : currentConfig.random,
    });
}
function addModelToClass(className, modelId) {
    const currentConfig = getModelClass(className);
    if (!currentConfig) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    if (currentConfig.models.includes(modelId)) {
        return;
    }
    const newModels = [...currentConfig.models, modelId];
    setModelClassModels(className, newModels);
}
function removeModelFromClass(className, modelId) {
    const currentConfig = getModelClass(className);
    if (!currentConfig) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    const newModels = currentConfig.models.filter(id => id !== modelId);
    if (newModels.length < currentConfig.models.length) {
        setModelClassModels(className, newModels);
    }
}
function setModelClassRandom(className, random) {
    const currentConfig = getModelClass(className);
    if (!currentConfig) {
        throw new Error(`Model class '${className}' does not exist`);
    }
    overrideModelClass(className, {
        models: currentConfig.models,
        random,
    });
}
function resetModelClass(className) {
    overrideModelClass(className, {});
}
function getAllModelClasses() {
    const result = {};
    for (const className of getModelClassNames()) {
        const config = getModelClass(className);
        if (config) {
            result[className] = config;
        }
    }
    return result;
}
function updateModelClasses(updates) {
    for (const [className, config] of Object.entries(updates)) {
        overrideModelClass(className, config);
    }
}
//# sourceMappingURL=model_class_config.js.map