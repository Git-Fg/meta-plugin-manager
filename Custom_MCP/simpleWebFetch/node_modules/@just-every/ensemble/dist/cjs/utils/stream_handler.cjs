"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamHandler = void 0;
exports.createStreamHandler = createStreamHandler;
exports.createMessageDeltaTransformer = createMessageDeltaTransformer;
exports.createMessageCompleteTransformer = createMessageCompleteTransformer;
const pause_controller_js_1 = require("./pause_controller.cjs");
class StreamHandler {
    options;
    constructor(options = {}) {
        this.options = options;
    }
    async *handleStream(stream, transformer) {
        const { pauseCheckInterval = 100, abortSignal, providerName = 'Unknown', modelName = 'Unknown' } = this.options;
        try {
            for await (const chunk of stream) {
                if ((0, pause_controller_js_1.isPaused)()) {
                    console.log(`[${providerName}] System paused during stream for model ${modelName}. Waiting...`);
                    await (0, pause_controller_js_1.waitWhilePaused)(pauseCheckInterval, abortSignal);
                    console.log(`[${providerName}] System resumed, continuing stream for model ${modelName}`);
                }
                const events = transformer(chunk);
                if (events) {
                    if (Array.isArray(events)) {
                        for (const event of events) {
                            yield event;
                        }
                    }
                    else {
                        yield events;
                    }
                }
            }
        }
        catch (error) {
            yield {
                type: 'error',
                error: error.message || 'Unknown streaming error',
                code: error.code,
                details: error.details,
                recoverable: error.recoverable,
                timestamp: new Date().toISOString(),
            };
        }
    }
}
exports.StreamHandler = StreamHandler;
function createStreamHandler(options = {}) {
    return new StreamHandler(options);
}
function createMessageDeltaTransformer(messageId) {
    let order = 0;
    return function transformMessageDelta(content) {
        return {
            type: 'message_delta',
            content,
            message_id: messageId,
            order: order++,
            timestamp: new Date().toISOString(),
        };
    };
}
function createMessageCompleteTransformer(messageId) {
    return function transformMessageComplete(content) {
        return {
            type: 'message_complete',
            content,
            message_id: messageId,
            timestamp: new Date().toISOString(),
        };
    };
}
//# sourceMappingURL=stream_handler.js.map